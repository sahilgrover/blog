<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[PAG, IIT Roorkee]]></title>
  <link href="http://pag.sdslabs.co/blog//atom.xml" rel="self"/>
  <link href="http://pag.sdslabs.co/blog//"/>
  <updated>2013-12-14T10:37:05+05:30</updated>
  <id>http://pag.sdslabs.co/blog//</id>
  <author>
    <name><![CDATA[Programming & Algorithms Group, Software Development Section, IIT Roorkee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPOJ-COINS]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/12/11/spoj-coins/"/>
    <updated>2013-12-11T19:39:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/12/11/spoj-coins</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/COINS/">Problem</a></strong>: Given, a gold coin in Byteland, find the maximum amount of American dollars you can get for it. </p>

<p><strong>EXPLANATION</strong> :</p>

<p>Consider a golden coin with a number ‘n’ on it. Now, the coin can be exchanged by n/2, n/3, n/4 coins only (all rounded down). Obviously, one would exchange the coins only if n/2+n/3+n/4 is greater than n. And similar holds for n/2, n/3, and n/4 and so on. Looking into the pattern carefully, all the numbers less than 12, if exchanged with coins, would return either lesser or equal to the number. So, it is better to exchange them directly by American dollars (1:1). Let’s try to solve it with a recursive function (a function in which we call our same function to solve it) :</p>

<p><em>Pseudocode of the function</em> :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Return type coin (variable type n)
</span><span class="line">if(n&lt;12)
</span><span class="line">	return n;
</span><span class="line">else
</span><span class="line">	return summation over i of (maximum of n/i and coin(n/i))
</span><span class="line">	//here i is 2,3 and 4.</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Ok, now an example, say 40:
If I would exchange 40 by coins:-40/2+40/3+40/4=20+13+10=43. But that’s not the correct answer.
20=20/2+20/3+20/4=10+6+5=21
Now, as all the numbers have been reduced to numbers less than 12, they would return the same value.
13=13/2+13/3+13/4=6+4+3=13
10 being lesser than 12 would return the same value. So, 21+13+10= (44) American dollars would be the maximum one can get.</p>

<p>Considering 81:
81/2+81/3+81/4 = 40+27+20
40=20+13+10;
27=13+9+6=28;
20=10+6+5=21;
Correct answer being 93.
Notice that 20 is being tested again (resulting from 40). We thus try to solve this problem with memoization (technique of storing already-calculated values for a function in a cache) which optimizes the solution.
It stores the value once calculated in the function and returns this value when called without performing those calculations again. So, the pseudo code of the function finally becomes:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">One must use the map library for using memoization.
</span><span class="line">
</span><span class="line">static map&lt;variable(n) type, function return type&gt; memo;
</span><span class="line">if(n&lt;12)
</span><span class="line">	{return n;}
</span><span class="line">if(memo.count(n)&gt;0)
</span><span class="line">	return memo[n];
</span><span class="line">else
</span><span class="line">	long long int ret;
</span><span class="line">	ret= summation over i of (maximum of n/i and coin(n/i));  i=[2,3,4]
</span><span class="line">	memo[n]=ret;
</span><span class="line">	return ret;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This makes the function well within the time-limit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-PTIME]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/12/11/spoj-ptime/"/>
    <updated>2013-12-11T19:17:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/12/11/spoj-ptime</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/PTIME/">Problem</a></strong>:  To write the prime factorisation of N! (N factorial).</p>

<p><strong>Explanation</strong> :</p>

<p>The prime factorisation of N! would only contain primes less than  or equal to N.  Our main job is to find out the power of each prime factor and then write the prime factorisation in the correct form.
Since the given N is always greater than or equal to 2, its factorial (N!) would have 2 in its prim factorisation. Now let us start by finding the power of 2 in the prime factorisation of N!
N!  =  1<em>2</em>3…….(N-2)<em>(N-1)</em>N
The number of integers less than or equal to N having a factor of 2 is:
Floor(N/2)
Some of the integers would be having more than one 2 in their prime factorisations ( 4 = 2<em>2, 12 = 2</em>2*3)
So the number of integers less than or equal to N having a factor of 4 ( 2^2) is :
Floor(N/2^2)
Similarly the process will continue till 2^i &gt; N. 
So the power of 2 in the prime factorisation of N! would be:
 Floor(N/2) + Floor(N/2^2) + Floor(N/2^3) + …….. + Floor(N/2^i)                           <br />
                                             where i is the highest number with 2^i &lt;= N
Similarly doing the process for all the prime factors  less than or equal to N, prime factorisation of N! can be obtained where N can be as large as 10000.</p>

<p><em>Pseudocode</em> :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for i = 2 to N
</span><span class="line">	k = 0
</span><span class="line">	for a = 2 to sqrt(i)
</span><span class="line">		if i % a = 0
</span><span class="line">			k = 1
</span><span class="line">			exit loop
</span><span class="line">	if k = 0           // i is prime
</span><span class="line">		s = 0
</span><span class="line">		e = N/i
</span><span class="line">		while e &gt; 0
</span><span class="line">			s = s + e
</span><span class="line">			e = e/i
</span><span class="line">		// after loop completes s would be the power of i in prime factorisation of N!	</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM Qualifications 2013]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/11/25/acm-qualifications-2013/"/>
    <updated>2013-11-25T22:20:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/11/25/acm-qualifications-2013</id>
    <content type="html"><![CDATA[<p>As a long-awaited winter break comes closer catalyzing our recovery from the haunting memories of a badly screwed up end sem, it’s  good news for the geeks at IIT Roorkee coming after the online prelims of the ACM ICPC Indian Regionals. ACM ICPC is arguably the most reputed programming competition for college students across the world, and seeing Roorkee perform impressively at this huge scale makes us all really proud.</p>

<p>In India there are three sites which play host to the ACM ICPC Regionals: IIT Kanpur, IIT Kharagpur and Amritapuri. There have been a total of 14 qualifications from IIT Roorkee across the three sites this year, a new record in itself for the institute. In the regionals, which will be held around mid December, a total of about 600 teams from the very best technical institutes of the country and abroad shall be competing for their shot at a glorious opportunity of participating in the World Finals of the ACM ICPC. Every year the World Finals are held early July in Russia. This is a great achievement for the programmers and geeks alike at IIT Roorkee; and a record that we should strive to improve every year.</p>

<p>PAG congratulates all the teams that will be representing IIT Roorkee at the Regionals this year and wishes them the very best of luck as they gear up to take on the best in the business.</p>

<p>Here are the team and students from IIT Roorkee who have qualified for the ACM ICPC  Regionals 2013:</p>

<h3 id="amritapuri">Amritapuri</h3>

<ul>
  <li><strong>11coders</strong>
    <ul>
      <li>Anubhav Bindlish† (CSE 2nd year)</li>
      <li>Aman Kumar Kedia† (CSE 2nd year)  	</li>
      <li>Kshitij Bathla† (CSE 2nd year)</li>
    </ul>
  </li>
  <li><strong>the-royal-flush</strong>
    <ul>
      <li>Jaspreet Singh (CSE 4th year)</li>
      <li>Arpit Dua (MSP 5th year)	</li>
      <li>Sukun Tarachandani (EPE 4th year)</li>
    </ul>
  </li>
  <li><strong>frick-freak</strong>
    <ul>
      <li>Ch. S Pramod (ECE 3rd year)</li>
      <li>R Shiva Tejesh (ECE 3rd year)</li>
      <li>Revanth Reddy (EE 3rd year)</li>
    </ul>
  </li>
  <li><strong>3Spades</strong>
    <ul>
      <li>Adury Surya Kiran† (ECE 3rd year)</li>
      <li>Praneeth Reddy† (ECE 3rd year)</li>
      <li>Harsh Jhamtani† (CSE 4th year)</li>
    </ul>
  </li>
  <li><strong>tehloneclubs</strong>
    <ul>
      <li>Vaibhav Gupta (CSE 4th year)</li>
      <li>Gaurav Singh   (CSE 4th year)</li>
      <li>Sushant Ojal (CSE 4th year)</li>
    </ul>
  </li>
  <li><strong>bapcoders</strong>
    <ul>
      <li>Pankaj Gudlani (CSE 2nd year)</li>
      <li>Ankur Garg (CSE 2nd year)</li>
      <li>Bharat Gaind (CSE 2nd year)</li>
    </ul>
  </li>
  <li><strong>the-mathletes</strong>
    <ul>
      <li>Aman Tripathi (EE 3rd year)</li>
      <li>Ankit Patel (CSE 3rd year)</li>
      <li>Saurabh Suman (ECE 3rd year)</li>
    </ul>
  </li>
  <li><strong>progenius</strong>
    <ul>
      <li>Rajat Jain† (CSE 2nd year)</li>
      <li>Divij Bindlish (EE 2nd year)</li>
      <li>Vibhor Goel (EE 2nd year)</li>
    </ul>
  </li>
  <li><strong>hedylogos</strong>
    <ul>
      <li>Saurabh Paliwal (CSE 4th year)</li>
      <li>Aayush Gupta (CSI 4th year)</li>
      <li>Siddharth Maheshwari (CSE 4th year)</li>
    </ul>
  </li>
  <li><strong>inquisitive</strong>
    <ul>
      <li>Abhishek Kandoi†       	(CSE 2nd year)</li>
      <li>Priyanshu Sheth†        	(CSE 2nd year)</li>
      <li>Satyam Vijay†               	(CSE 2nd year)</li>
    </ul>
  </li>
  <li><strong>codewarrior</strong>
    <ul>
      <li>Shubham Kansal†        	(CSE 3rd year)</li>
      <li>Shubham Mittal                   (MSM 5th year)           	</li>
      <li>Vishu Goyal                    	(CSE 3rd year)</li>
    </ul>
  </li>
</ul>

<h3 id="iit-kanpur">IIT Kanpur</h3>

<ul>
  <li><strong>3Spades</strong>
    <ul>
      <li>Adury Surya Kiran†     	(ECE 3rd year)</li>
      <li>Praneeth Reddy†    	(ECE 3rd year)</li>
      <li>Harsh Jhamtani† (CSE 4th year)</li>
    </ul>
  </li>
  <li><strong>inquisitive</strong>
    <ul>
      <li>Abhishek Kandoi†	(CSE 2nd year)</li>
      <li>Priyanshu Sheth†        	(CSE 2nd year)</li>
      <li>Satyam Vijay†               	(CSE 2nd year)</li>
    </ul>
  </li>
</ul>

<h3 id="iit-kharagpur">IIT Kharagpur</h3>

<ul>
  <li><strong>the-royal-flush</strong>
    <ul>
      <li>Jaspreet Singh (CSE 4th year)</li>
      <li>Arpit Dua (MSP 5th year)</li>
      <li>Sukun Tarachandani (EPE 4th year)</li>
    </ul>
  </li>
</ul>

<p><em>People marked with † are members of Programming and Algorithms Group</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-DCEPC202]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202/"/>
    <updated>2013-11-08T13:33:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/DCEPC202/">Problem</a></strong> :
Given the number of unique shortest paths across a rectangular grid with broken tiles, to find its dimensions.</p>

<p><strong>Pre-requisites</strong> : Principle of inclusion and exclusion, Binary Search</p>

<p><strong>Explanation</strong> :</p>

<p>First consider a corridor of dimension m*n, with no broken tiles. Now, for ‘shortest’ path, you can only move to tiles (x,y+1) or (x+1,y) if you’re currently on tile (x,y). So, to go from (0,0) to (m-1,n-1), you need to move m+n-2 steps with m-1 steps in x direction and n-1 steps in y direction. The number of unique paths will be the number of ways in which you can choose those m-1 (or n-1) steps out of the total m+n steps 
i.e. <sup>(m+n-2)</sup>C<sub>(m-1)</sub></p>

<p>Now, lets take into account the broken tiles:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class=""><span class="line">  .____.____.____.____.____.____.G
</span><span class="line">  |    |    |    |    |    |    |
</span><span class="line"> 4|    |    |    | F* |    |    |
</span><span class="line">  .____.____.____.____.____.____.
</span><span class="line">  |    |    |    |    |    |    |
</span><span class="line"> 3|    |    |    |    |    |    |
</span><span class="line">  .____.____.____.____.____.____.
</span><span class="line">  |    |    |    |    |    |    |
</span><span class="line"> 2| C *|    |    | D* |    | E* |
</span><span class="line">  .____.____.____.____.____.____. 
</span><span class="line">  |    |    |    |    |    |    |
</span><span class="line"> 1|    |    |    |    |    |    |
</span><span class="line">  .____.____.____.____.____.____.
</span><span class="line">  |    |    |    |    |    |    |
</span><span class="line"> 0|    |    |    | B *|    |    |
</span><span class="line">  .____.____.____.____.____.____.
</span><span class="line"> A  0     1        n/2       n-1
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>* represents broken tiles.</p>

<p>Now, employing the principle of inclusion and exclusion, we will first determine the total number of paths and then subtract the number of paths passing through the broken tiles. The total number of paths, therefore, is:</p>

<p>N(AG) - N(AB)*N(BG) - N(AC)*N(CG) - N(AD)*N(DG) - N(AE)*N(EG) - N(AF)*N(FG) + N(AB)*N(BD)*N(DG) + N(AB)*N(BE)*N(EG) + N(AC)*N(CD)*N(DG) + N(AC)*N(CF)*N(FG) + N(AD)*N(DE)*N(EG) + N(AD)*N(DF)*N(FG) - N(AB)*N(BD)*N(DF)*N(FG) - N(AC)*N(CD)*N(DE)*N(EG)</p>

<p>where:</p>

<p>N(AG)= <sup>(n - 1 + 4)</sup>C<sub>4</sub> = p</p>

<p>N(AF)= <sup>(n/2 + 4)</sup>C<sub>4</sub> = q</p>

<p>N(AE)=N(CG)= <sup>(n-1+2)</sup>C<sub>2</sub> = r</p>

<p>N(BG)= <sup>(n - 1 - n/2 + 4)</sup>C<sub>4</sub> = s</p>

<p>N(AD)=N(CF)= <sup>(n/2 + 2)</sup>C<sub>2</sub> = t</p>

<p>N(BE)=N(DG)= <sup>(n - 1 - n/2 + 2)</sup>C<sub>2</sub> = u</p>

<p>N(AB)=N(AC)=N(BD)=N(CD)=N(DE)=N(DF)=N(EG)=N(FG)=1</p>

<p>So, the final expression for number of unique paths, k is:</p>

<p>k = p - 1*s - 1*r - t*u - r*1 - q*1 + 1*1*u + 1*u*1 + 1*1*u + 1*t*1 + t*1*1 + t*1*1 - 1 - 1</p>

<p>=&gt;  k = p - s - 2*r - t*u -q + 3*u + 3*t -2</p>

<p>According to the problem, we have to find out the dimension of the corridor i.e. n for a given k. For this we will make an array of the k values of all 1&lt;=n&lt;=10000 beforehand. Now for each k, we’ll carry out a binary search in the array to find out the value of n for which no. of paths is equal to or just larger than k.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Year Recruitment Results]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/10/19/first-year-recruitment-results/"/>
    <updated>2013-10-19T22:30:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/10/19/first-year-recruitment-results</id>
    <content type="html"><![CDATA[<p>Congratulations to everyone who made it to the group. We were extremely happy to see the response by the first yearites. We got to interview some of the most talented first yearities in our campus and it was a wonderful experience for us and hopefully for them too. We had to reject people only because of limited vacancies even though they were all equally capable.</p>

<p>Here comes the result of Programming and Algorithms Group’s first year recruitment test : </p>

<ul>
  <li>Abhishek Uppal</li>
  <li>Akhil Gupta</li>
  <li>Anal Kumar Shahi</li>
  <li>Chitra Kumari</li>
  <li>Dhaval Kapil</li>
  <li>Eklavya Sharma</li>
  <li>Harsh Kumar Sahu</li>
  <li>Ishu</li>
  <li>Jahnavi Singh</li>
  <li>Jay Bosamiya</li>
  <li>M. Sai Varun Reddy</li>
  <li>Rahul Yadav</li>
  <li>Rishabh Ravi Gupta</li>
  <li>Shubhangi Singar</li>
  <li>Vaibhav Daga</li>
  <li>Vinay Malik</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-DGAME]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/10/18/spoj-dgame/"/>
    <updated>2013-10-18T21:16:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/10/18/spoj-dgame</id>
    <content type="html"><![CDATA[<p><strong>Prerequisites</strong> :  Game of Nim</p>

<p><strong><a href="http://www.spoj.com/problems/DGAME/">Problem</a></strong> : Game of Nim with variations. (N piles with i<sup>th</sup> pile containing either 2<em>i or 2</em>i+1 stones where even number of stones may be removed from selected pile.)</p>

<p><strong>Explanation</strong> :</p>

<p>At every index i, can have stones in two ways, so total no. of ways comes out to be 2 * 2 * &#8230; . * 2 (n times).</p>

<p>Now whether an index have 2<em>i or 2</em>i+1 stones the game remains unaffected because if there are 2<em>i+1 stones in any pile there will be one stone left out anyways, and the game will be same as the one played with 2</em>i stones. We shall be considering only this case.</p>

<p>At any point of the game i<sup>th</sup> pile contains 2*(i - k) stones (where k is any arbitrary constant). Now you can interpret the question as the ith pile had i stones in the beginning and you can take out any positive number of stones from it. This is the standard nim game containing N piles, where the ith pile contains i stones.</p>

<p>Now our task is to find XOR of N numbers(1 to N). Every number can be represented 4*p+q where 0 &lt;= q &lt;= 3 and p is any arbitrary.</p>

<p>For every N of type 4*p+3, it can be easily proved that XOR of 1 to N is 0. So the first person will always lose the game. The answer for such numbers is zero.</p>

<p>For N of type 4*p+1 XOR of numbers from 1 to N is 1, so the first player can remove 1 stone from any pile containing odd number of stones so that the XOR becomes zero. There are (N+1)/2 piles containing odd number of stones, so the answer for this case is (N+1)/2.</p>

<p>For numbers of type 4<em>p or 4</em>p+2 XOR is N and N+1 respectively So first player can make XOR zero by removing stones from any pile whose most significant bit is same as the most significant bit of N. Thus the answer for this case is the number of piles which has x stones, such that when x is represented in binary, it has the same number of bits as the binary representation of N. This can be obtained by subtracting from N the maximum power of 2 which is less than or equal to N.</p>

<p><strong>Links</strong> : <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=algorithmGames">Game of Nim</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-RRSCHED]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/10/03/spoj-rrsched/"/>
    <updated>2013-10-03T18:38:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/10/03/spoj-rrsched</id>
    <content type="html"><![CDATA[<p><strong>Problem</strong> : <a href="http://www.spoj.com/problems/RRSCHED/">RRSCHED</a></p>

<p><strong>Difficulty</strong> : Medium</p>

<p><strong>Prerequisites</strong> : BIT</p>

<p><strong>Explanation</strong> : </p>

<p>A very naive approach would be to iterate over time and keep on decreasing the no of tasks to be performed and storing the task completion time in a separate array.This implementation would definitely give TLE  O(N*T) with the given constraints.</p>

<p>In the above approach we can observe that we can do better by jumping times from t = completion of easiest task (w.r.t time) to t = completion of next easiest task . </p>

<p>For this we need to sort the input array w.r.t time .But we would also want their original indices(because order matters).So you can use pair&lt;int,int&gt;  to store both the index and time  of a task.That way you would not lose your index’s by sorting the array.</p>

<p>In the following discussion:</p>

<p>Pair [i] denotes i th pair in sorted array
Pair[i].Time denotes time needed for ‘Pir[i].Index’ th task to complete.</p>

<p>Now for every iteration all we need to do is to keep track of  Current time and do as follows.</p>

<ol>
  <li>
    <p>Time Taken for present task to be completed
 = 	(no of remaining elements)*(Pair[i].Time-Pair[i-1].Time) +
 		1*no of Tasks before Pair[i].Index which are not completed</p>
  </li>
  <li>
    <p>Extra Time to complete the  round
 = 1*no of Tasks after Pair[i].Index which are not completed.</p>
  </li>
  <li>
    <p>Update Pair[i].Index as completed</p>
  </li>
</ol>

<p>Thus BIT comes in handy here where we have to query the no of tasks not completed and update a task as completed in O(logN). For this purpose initially keep a BIT array and update every element by ‘+1’ which means that the task is not completed yet.You can use Update(i,-1) to update the task as completed. You can find the no of tasks which are not completed  before an index i by Query(i).</p>

<p>The <a href="http://code.hackerearth.com/d8db76J">pesudo code</a> is as follows:</p>

<pre><code>//Initialize bit array to zero 

BIT[MaxN] = 0

// Update bit array 

Upadte(i , x)
	for(; i &lt;= n; i += i&amp;-i)
    	BIT[i] += x

//Query Cummulative Frequency in a bit array 

Query(i)
	s=0
	for(; i&gt;0 ; i-=i&amp;-i)
    	s += BIT[i]
	return s

//Take Input and Do the necessary initializations for BIT array

TakeInput()
for(i = 1; i &lt;= N; i++)
	Update(i, 1)

//Main Part

CurrentTime = 0
for(i = 1; i &lt;= N; i++)

	//N-i+1 total uncompleted tasks
	
	CurrentTime += (Pair[i].Time - Pair[i-1].Time - 1)*(N-i+1)
	
	//query for uncompleted tasks before the present task
	
	CurrentTime +=  Query(Pair[i].Index)
	
	//Store the final anwer for the present task
	
	Answer[Pair[i].Index] = CurrentTime
	
	//Update current task as completed
	
	Update(Pair[i].Index, -1)
	
	//Increase by no of uncompleted tasks after the present task
	
	CurrentTime += (N-i) - Query(Pair[i].Index)

//Note that the above psudo code also handles the case where two tasks have equal completion Time.
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ TIC-TAC-TOE 2]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/09/27/tic-tac-toe-2/"/>
    <updated>2013-09-27T16:30:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/09/27/tic-tac-toe-2</id>
    <content type="html"><![CDATA[<p><strong>Problem</strong> : <a href="http://www.spoj.com/problems/TOE2/">Tic Tac Toe 2</a></p>

<p><strong>Difficulty</strong> : Easy</p>

<p><strong>Prerequisites</strong> : Simple Maths</p>

<p><strong>Explanation</strong> : </p>

<p>For the given board configuration we have to check whether it is the final state of some possible tic-tac-toe game or not.
Let numX, numO and numE represents the number of X’s, number of O’s
and number of dots in given board configuration.
Also let xWins and oWins denotes the number of x winning possible configuration and number of o winning possible configurations respectively.
There will be total of 8 winning configurations:</p>

<pre><code>  |    x   |       |        |
  |        |   x   |        |
  |        |       |   x    |


  |    x   |       |        |
  |    x   |       |        |
  |    x   |       |        |


  |    x   |   x   |   x    |
  |        |       |        |
  |        |       |        |


  |        |       |        |
  |        |       |        |
  |    x   |   x   |   x    |


  |    x   |       |        |
  |    x   |       |        |
  |    x   |       |        |


  |        |       |   x    |
  |        |       |   x    |
  |        |       |   x    |


  |        |   x   |        |
  |        |   x   |        |
  |        |   x   |        |


  |        |       |        |
  |    x   |   x   |   x    |
  |        |       |        |
</code></pre>

<p><strong>Pseudocode</strong> :</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">If |numX - numO|&lt;=1 # Since each player gets an alternative chance in tic tac toe game
</span><span class="line"> 	If numE&gt;0 and xWins=0 and oWins=0  #Case when there is empty block and no player has win till now
</span><span class="line">		then it is "invalid"
</span><span class="line">	If xWins&gt;0 and oWins&gt;0 #Case when there is winning configuration of both players simultaneously
</span><span class="line">		then it is "invalid"
</span><span class="line">	If xWins&gt;0
</span><span class="line">		If numX &gt; numO
</span><span class="line">			then it is "valid"
</span><span class="line">		Else 
</span><span class="line">			then it is "invalid"
</span><span class="line">	If oWins&gt;0
</span><span class="line">		If numX &lt; numO
</span><span class="line">			then it is "valid"
</span><span class="line">		Else 
</span><span class="line">			then it is "invalid"
</span><span class="line">	rest all are "valid"
</span><span class="line">Else
</span><span class="line">	rest all are "invalid"</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ MORSE]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/09/16/spoj-morse/"/>
    <updated>2013-09-16T18:30:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/09/16/spoj-morse</id>
    <content type="html"><![CDATA[<p><strong>Prerequisites</strong> : Dynamic Programming, Trie</p>

<p><strong><a href="http://www.spoj.com/problems/MORSE/">Problem</a></strong> : </p>

<p>Given the Morse code for English alphabet, a list of words(dictionary) and a Morse sequence, the task is to compute the number of distinct phrases that can be obtained from the sequence using words from the dictionary.</p>

<p><strong>Explanation</strong> :</p>

<p>In this problem, we are given N words in a dictionary and a Morse string containing ‘.’ and ‘-’ of length L. Now we are asked to find how many strings from the dictionary words when converted to their Morse part will exactly map to the given Morse sequence.</p>

<p>Say we have .-..–.-..-.-…- and the dictionary as a aa bc acm shuka etc., one naive way is to generate all possible strings using the given words of the dictionary and see if they map to the given Morse string or not. But this approach is too slow and can take centuries to calculate if number of letters in dictionary are large enough (O(L<sup>N</sup>)).</p>

<p>So, one thing to observe here is there will be several sub-cases counted a lot more times than required as in sub part of Morse string ‘.-..-’ might map to one english string and the rest part of Morse string doesn’t, so for calculating that this isn’t a valid string will itself take order O(L^N) time. </p>

<p>Such problems where only number of solutions are to be found are approached as given:</p>

<ol>
  <li>Start iterating Morse string either from left or right.</li>
  <li>At each point,check if the current string covered using the iterator maps to any word in the dictionary(So this iteration is finding the last(or first) word that could be placed from dictionary to the position of the iterator).</li>
  <li>When a word is found,use recursion on the remaining string.</li>
</ol>

<p>Here we were also given some constraints to help us out with our complexity analysis:</p>

<ol>
  <li>Length of Morse string : 10000</li>
  <li>Length of a word : 20</li>
  <li>Number of words in the dictionary : 10000 </li>
</ol>

<p>The pseudocode of the above idea looks something like :</p>

<pre><code>    Function TotalStrings(int i) //the current position of the iterator
	{

		for(k from i to Morselength) // Morselength stores the length of the Morse string
		{

			if string[i…k] is valid and in dictionary
			then answer = answer + TotalStrings(k)

		}
	   
		return answer;

	}
</code></pre>

<p>Disclaimer: The below arguments are assuming we can search a Morse in a dictionary in O(1) time.</p>

<p>The above solution still doesn’t seem to ease our problem as we still have to face the worst case time complexity as O(L^N) but whenever we find some repeating subproblems we should always think of Dynamic Programming.</p>

<p>Now the question is: What if in the above code, the value TotalStrings(k) was already known to us? In that case what would the time complexity be?</p>

<p>It will be linear if all values of TotalStrings(k) are pre-known. Here comes the concept of Dynamic programming in which we can store the values of TotalStrings(k) whenever we calculate it. As we use linear time for calculating all the TotalStrings(k) with k in (0,Morselength),we use a total of O(L^2) time where L is the length of the Morse string.</p>

<p>All we need to change in code is before returning answer, just store the answer calculated in some global array so that next time the same value is asked it could be returned immediately.</p>

<p>Now,taking advantage of the constraints :</p>

<p>Length of a word cannot exceed 20 as given in the question,hence the conclusions are :</p>

<ol>
  <li>Each alphabet can have maximum 4 ‘.’ or ’-‘ characters. So a word of length 20 can have maximum 80 Morse characters</li>
  <li>Hence in the inner loop of the above pseudo code k varies from i to i+80</li>
  <li>If the word searching is extremely fast, our complexity reduces to O(80*l)</li>
</ol>

<p>The problem left now is word searching. We can think of various methods and techniques to find a map from dictionary to the iterated part being used.</p>

<ol>
  <li>Hash maps</li>
  <li>STL library map</li>
  <li>Brute force</li>
  <li>Trie implementation</li>
</ol>

<p>Of all the above methods,the most reliable for this problem is trie, given the constraints and the difficulty in using large length strings(~80).</p>

<p>Trie implementation is simple and can be performed using arrays as well as link lists.</p>

<p><strong>Links</strong> :</p>

<p><a href="http://www.geeksforgeeks.org/trie-insert-and-search/">http://www.geeksforgeeks.org/trie-insert-and-search/</a></p>

<p><a href="http://en.wikipedia.org/wiki/Trie">http://en.wikipedia.org/wiki/Trie</a></p>

<p><strong>Related problem on trie</strong> :</p>

<p><a href="http://www.spoj.com/problems/REVFIB/">SPOJ-REVFIB</a> (Difficulty Level: Hard)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ NACCI]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/08/28/spoj-nacci/"/>
    <updated>2013-08-28T20:00:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/08/28/spoj-nacci</id>
    <content type="html"><![CDATA[<p>Prerequisites : Matrix Exponentation.</p>

<p><a href="http://www.spoj.com/problems/NACCI/">Problem</a> : </p>

<p>Find f[M] such that if (M &gt; N) f[M] = sum(f[M - i]) for(i = 1 to N) else f[M] = M.</p>

<p>Explanation :</p>

<p>For convenience let us take k = 4. So f[n] = f[n - 1] + f[n - 2] + f[n - 3] + f[n - 4].
Let us consider two matrices A,B of size (4 X 4)</p>

<p>Matrix A :</p>

<pre><code>{ f[i]  f[i - 1]  f[i - 2] f[i - 3] }
{  0        0        0         0    }
{  0        0        0         0    }
{  0        0        0         0    }
</code></pre>

<p>Matrix B :</p>

<pre><code>{ 1   1   0   0 }
{ 1   0   1   0 }
{ 1   0   0   1 }
{ 1   0   0   0 }
</code></pre>

<p>MAtrix A X B :</p>

<pre><code>{ (f[i]+f[i-1]+f[i-2]+f[i-3]   f[i]   f[i - 1]   f[i - 2] }
{  0                             0        0         0     }
{  0                             0        0         0     }
{  0                             0        0         0     }
</code></pre>

<p>That will be equal to</p>

<pre><code>{ (f[i+1]   f[i]   f[i - 1]   f[i - 2] }
{    0        0        0         0     }
{    0        0        0         0     }
{    0        0        0         0     }		
</code></pre>

<p>So multiplying matrix A by matrix B by p times leaves f[i+p] in the first row first column position.
Let initially Matrix A be</p>

<pre><code>{ f[3]     f[2]     f[1]    f[0] }
{  0        0        0       0   }
{  0        0        0       0   }
{  0        0        0       0   }
</code></pre>

<p>So Multiplying A with B by p times leaves f[3+p] in the first row first column element of product matrix.</p>

<p>To get M’th element we just need to multiply A with B by M - 3 times. As M is very large we can calculate this my repeated squaring in O(logM) multiplications. For a (N X N) matrix as each matrix multiplication takes O(N^3) steps overall complexity becomes O(log(M)*(N^3)).</p>

<p>For an (N X N) matrix, B might look as </p>

<p>Matrix B :</p>

<pre><code>{ 1  1  0  0  0 ...}
{ 1  0  1  0  0 ...}
{ 1  0  0  1  0 ...}
{ 1  0  0  0  1 ...}  
{ .................}
</code></pre>

<p>(So on till N rows N columns)</p>

<p>To be generalized let b(i,j) be i’th row j’th column element of matrix. Then b(i,j) = 1 if (j == 0) or (j == i + 1)
In general any linear equation of above type like f[n] = a1<em>f[n - 1] + a2</em>f[n - 2] + … can be solved by making B[i][0] = ai for all (i = 0 to N - 1)</p>

<p>PseudoCode :</p>

<pre><code>int[][] MatrixMul(int[][] A, int[][] B)

	int[][] P;

	int i,j,k;

    for(k = 0 to n - 1)

	    for(i = 0 to n - 1)
	
    	    for(j = 0 to n - 1)
		
        	    P[i][j] += A[i][k] * B[k][j]
		
        	end loop
	
	    end loop

	end loop

	return P

end MatrixMul


int[][] PowerMatrix(int[][] B , power) :

	if(power == 1) :
	
    	return B

	else

    	int[][] temp = PowerMatrix(B , power / 2) 
	
    	temp = MatrixMul(temp,temp)
	
	    if(power % 2 == 1) :
	
    	    temp = MatrixMul(temp,B)
	
	    end if
	
    	return temp

	end ifelse

end PowerMatrix


int NACCI(int M , int N) :

	if M &lt; N
	
    	return M
	else

    	int A[N][N],B[N][N],i,j;
	
    	for(j = 0 to N - 1)
	
        	A[0][j] = N - 1 - j
    
   	 	end loop
	
	    for(i = 1 to N - 1)
		
    	    for(j = 0 to N - 1)
		
        	    A[i][j] = 0
		
       		end loop
	
    	end loop
	
    	for(i = 0 to N - 1)
	
        	B[i][0] = 1
		
        	for(j = 1 to N - 1)
		
	            if (j == i + 1)
			
    	            B[i][j] = 1
			
        	    else 
			
            	    B[i][j] = 0
			
            	end ifelse
		
        	end loop

    	end loop
	
	    A = MatrixMul( A , PowerMatrix(B,M - N + 1) )
	
    	retrurn A[0][0]

	end ifelse

end NACCI
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-TREZOR]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/08/21/spoj-trezor/"/>
    <updated>2013-08-21T00:29:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/08/21/spoj-trezor</id>
    <content type="html"><![CDATA[<p><a href="http://www.spoj.com/problems/TREZOR/">Problem</a> :</p>

<p>Given a 2-D Coordinate Plane, find how many points are visible from one point. Two persons are standing at two other points, and you need to find how many other points are visible to both, points visible to only one, and none.</p>

<p>Explanation:</p>

<p>For Simplicity consider one guard standing at <strong>(0,0)</strong> and rectangle of size <strong>L*(A+B+1)</strong> is present with corner points <strong>(1,0) (L,0) (1,A+B) (L,A+B)</strong> and other guard is standing at <strong>(0,A+B)</strong>.</p>

<p>Lets discuss the solution to one guard. A point <strong>(X,Y)</strong> will be blocked by another point <strong>(X1,Y1)</strong> to the origin if the slopes of lines joining points are equal, i.e <strong>X / X1 = Y / Y1 = Z (Z &gt; 1)</strong>. That means <strong>X = X1 * Z</strong> and <strong>Y = Y1 * Z</strong>, which inturn means that <strong>X</strong> and <strong>Y</strong> are not coprimes (have a common factor). So for every horizontal row <strong>(i,Y)</strong> number of points visible to origin are number of <strong>i’s</strong> from <strong>1 to L</strong> that are coprime to <strong>Y</strong>.</p>

<p>Similar is the situation to other guard, points of the form <strong>(i,Y)</strong> are visible if and only if <strong>‘i’</strong> is coprime to <strong>(A+B-Y)</strong>. and visible to both if <strong>‘i’</strong> is coprime to <strong>(A+B-Y)</strong> and <strong>Y</strong>, which means <strong>‘i’</strong> is coprime to <strong>(A+B-Y)*Y</strong>..</p>

<p>Now the problem is reduced for a given <strong>Y</strong> , how many numbers from <strong>1 to L</strong> are coprime to <strong>Y</strong>. For this we can prime factorize <strong>Y</strong> and use inclusion and exclusion principle on primes to find the final answer. Total there can be at max 6 prime factors to <strong>Y</strong>, as the product of first six primes  &gt; 4000 = <strong>(A+B)</strong>. Now it takes <strong>2^N = (2^6) = 64</strong> steps for finding number of coprimes of each Y, so 3 * 64 for each horizontal row, so (3 * 64 * 4000) for all rows  = 768000 steps which comes under time limit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Second Year Recruitment Results]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/08/11/second-year-recruitment-results/"/>
    <updated>2013-08-11T23:55:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/08/11/second-year-recruitment-results</id>
    <content type="html"><![CDATA[<p>Congratulations to everyone who made it to the group. We were extremely happy to see the response by second yearites. We got to interview some of the most talented coders in our campus and it was a wonderful experience for us and hopefully for them too. We had to reject people only because of limited vacancies even though they were all equally capable.</p>

<p>Here comes the result of Programming and Algorithms Group’s second year recruitment test : </p>

<ul>
  <li>Aakshesh Doshi</li>
  <li>Abhishek Kandoi</li>
  <li>Akarsh Agarwal</li>
  <li>Aman Kedia</li>
  <li>Anubhav Bindlish</li>
  <li>Bharat Gaind</li>
  <li>Deepali Jain</li>
  <li>Ishu goyal</li>
  <li>Kshitij Bathla</li>
  <li>Meghana Agrawal</li>
  <li>Mehak Gupta</li>
  <li>Priyanshu Seth</li>
  <li>Rajat Jain</li>
  <li>Sandeep Pathry</li>
  <li>Satyam Vijay</li>
  <li>Ujjawal Mittal</li>
  <li>Varun Syal</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ MBALL]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/08/05/spoj-mball/"/>
    <updated>2013-08-05T15:26:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/08/05/spoj-mball</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/MBALL/">Problem</a></strong> :
Given the possible ways of scoring in a game, you neeed to find in how many ways can a given score be achieved.</p>

<p><strong>Pre-requisites</strong> : <a href="http://www.topcoder.com/tc?d1=tutorials&amp;d2=dynProg&amp;module=Static">Dynamic Programming</a>(read DP)</p>

<p><strong>Explanation</strong> :</p>

<p>The problem is quite simple. The different ways of scoring can be as follows:</p>

<ul>
  <li>safety: 2 points</li>
  <li>field goal: 3 points</li>
  <li>touchdown: 6 points</li>
  <li>one-point conversion try after touchdown: 7 points</li>
  <li>two-point conversion try after touchdown: 8 points</li>
</ul>

<p>We start by subtracting the smallest possible score ie 2 from the given score and reduce it to smaller instance of the same problem. This way we continue till we reach 0. Then carry out this step with 3,6,7and 8 as well.</p>

<p>eg 10 points can be scored in following ways:</p>

<ul>
  <li>first 2 points and then scoring 8 points.
    <ul>
      <li>2 points can be scored in 1 way only and 8 points can be scored in following way:
        <ul>
          <li>first 2 points and then 6 points.</li>
          <li>first 3 points and then 5 points.</li>
          <li>first 4 points and then 4 points.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>first 3 points and then scoring 7 points.</li>
  <li>first 4 points and then scoring 6 points.</li>
  <li>first 5 points and then scoring 5 points.</li>
</ul>

<p>In each case we reduce the problem to a subproblem of the same type.</p>

<p>Notice a pitfall here. Even if there is just one test case (say S=10 itself), We are doing the computation for various subproblems again and again. eg we calculate the number of ways of scoring 6 points when we are calculating the number of ways of scoring 8 points. And we are doing this calculation again when we try to find number of ways scoring 10 points. </p>

<p>Basically we are solving the same sub problem again and again even when we have just one test case. Surely this method will timeeout. </p>

<p>So what do we do? We use DP. DP means we save the result of various sub problems so that we do not have to calculate them again and again. In this case, we make an array called <em>result[N]</em> (and initialise with -1) in which we store the number of ways of achieving <em>i</em> score for all <em>i</em> varying from 2 to <em>N</em>. Also there is only one way of achieving score of ‘0’. So <em>result[0]</em>=1. Now when we need to calcualte the number of ways of achieving score <em>i</em>, we check the array. If it contains -1, we calculate the result and update the array entry else we use the value from the array.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Welcome to Programming]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/07/30/welcome-to-programming/"/>
    <updated>2013-07-30T21:38:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/07/30/welcome-to-programming</id>
    <content type="html"><![CDATA[<p><strong>Algorithm</strong>: <em>(Just)</em> A sequence of steps to get stuff done?</p>

<p>Technically, yes. Many of us have in fact been using algorithms for most part of our lives even without realizing that we are. Take for instance, when you want to look up a particular word in the dictionary. How long would it take you if the words were all arranged randomly with absolutely no relation? It is an algorithm in itself when you search for a given word, matching the leftmost letter of the word and keep moving right. That instance when you choose a particular path over another when looking for the fastest way to reach a friend’s house, you are technically solving a classic example of the Shortest Path Problem, a problem which could trouble the best programmers for hours!</p>

<p>However with the increasing dependence on computers and electronic gadgetry, you no longer need algorithms to get stuff done, but also need algorithms to guide machines do stuff for you. There is a mind-bogglingly huge amount of data present on the web and picking out a particular one is a task in itself. From the smallest chipsets to the multi-billion dollar spaceships circling the Earth to a random game of chess played on a summer afternoon, there are both complex and simple algorithms involved in everything.  </p>

<p>The study of efficiency in algorithm design is of huge importance. You don’t just need to consider <em>how to get something done</em>, you need to find a way <em>to get something done quickly</em>. Imagine if your GPS were to look for all ways to get from A to B, total their distances and then return the best route. Or if in a game of chess with a computer, the program were to try all possibilities and all possibilities arising out of those possibilities and all possibilities arising out of those and so on before it were to make an optimal move. You need to design algorithms that not only solve a given problem, but do so in a reasonable amount of time.</p>

<p>And the best part about algorithmic and logical problems is that once you start getting the hang of it, it becomes huge fun! You no longer need to take time out of your daily routine to practice (read: play) on online judges; it finds time for itself! So much so that it soon become a passion (and in some occasional cases an ‘addiction’) which you pursue not only because you want to end up with a high paying job at Facebook or Google, but because you enjoy doing it! </p>

<p><strong>How to start Programming?</strong></p>

<p>Am I good enough?</p>

<p>Yes you are, if you think you are not, think again! We say you can be. All you need is good logical and reasoning skills. If you have been a mathematics enthusiast in your school time, you already have the instinct in you.</p>

<p>Let’s introduce you to the amazing world of programming and algorithms.</p>

<p>Getting Started:</p>

<p>1.Pick any programming language(C, C++, Java, Python) whichever you feel 
comfortable with. Or if you don’t know any, you can easily learn C or C++ in hardly two weeks’ time. Only basics concepts are to be grasped.</p>

<p>Here are some useful references to help you:</p>

<p><a href="https://www.facebook.com/groups/sdspag/549286215108068/">Schaum Programming with C++</a>: A very nice book to give you a quick introduction for C++</p>

<p><a href="https://dl.dropboxusercontent.com/u/56860240/C%2B%2B%20How%20to%20Program%2C%208th%20Edition.pdf">C++ How to Program, Deitel, 8th Edition</a>: For those who want more than just an introduction.</p>

<p><a href="http://ge.tt/9iw7sKn/v/0?c">Java How to Program, Deitel, 7th Edition</a>: For those who want to learn Java</p>

<p>2.Now that you have the tool, let’s use it to explore the algorithmic world</p>

<p>Here are some resources to make you familiar with the commonly used algorithms.</p>

<p><a href="https://www.coursera.org/course/algo">Coursera</a></p>

<p><a href="http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=IntroToAlgorithms">Stanford Open Class Room</a></p>

<p><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/index.htm">MIT Open Courseware</a></p>

<p><a href="https://www.facebook.com/groups/sdspag/files/">CLRS</a> : The Bible for Algorithms</p>

<p>3.So here comes the most important phase of your coding journey. Practice. Practice more. Solve questions and keep exploring. And remember this:Frustration is normal. Don’t give up during this phase as your failure teaches you more than your success. Proceed gradually. The experience you gain here is worth your effort. Check these out</p>

<p><a href="http://www.spoj.com/">SPOJ</a></p>

<p><a href="http://www.codechef.com/">Codechef</a></p>

<p><a href="http://projecteuler.net/about">Project Euler</a></p>

<p>4.If you wish to evaluate your progress, there are plenty of contests to keep you going. Apart from that, group contests prove very beneficial in improving your skills. You get to know your teammate’s approach (which may be better) too. </p>

<p>Participating in programming contests inculcates in you an urge to learn more and keeps you motivated.  You can find some ongoing contests here:</p>

<p><a href="http://www.codechef.com/">Codechef</a></p>

<p><a href="http://codeforces.com/">Codeforces</a></p>

<p>Also check out this <a href="http://www.quora.com/What-are-the-best-websites-a-programmer-should-visit/answer/Ashish-Gaur">answer</a> on quora for a more elaborate list. on quora for a more elaborate list.</p>

<p>Common <strong>Myths</strong> regarding Programming and Algorithms:</p>

<p>1.Programming is only for CS students.</p>

<p>Wrong! Here are the reasons:</p>

<p>You love maths, like solving puzzles and have an aptitude to do this, so you do it.Most of the CS companies like Microsoft, Facebook, Yahoo etc. are open for other branches too. If you are good enough in programming and algos then they will take you.</p>

<p>Even if you want to do higher studies, just try to explore what are the current research areas in your branch, you would find that most of them require programming - fields like Image processing, embedded systems, robotics, controls etc. Whichever field of engineering you are in , programming will help you somewhere.</p>

<p>2.You need to be an expert in a programming language to start with algorithms.</p>

<p>No, this opinion is completely wrong. You just need very basic knowledge of 
any language. They are just a tool, solving problems will automatically give you enough exposure to the language. An inquisitive mind and eagerness to learn is all that counts.</p>

<p><strong>Why PAG?</strong></p>

<p>With the huge influx of data in the ‘shared’ world; big-data, data mining, data extraction, data analysis, optimizations- these are topics that the coming generation of computer scientists needs to address. </p>

<p>Many of those computer scientists are now in college. Hopefully some of these world changers might be in India, and a few in IITR. PAG hopes to inculcate a feel for algorithms in these young engineers from the very beginning, get them acquainted with this field and help them realize why this fields bears importance in the real world. But then, why is solving problems on an online judge which thousands have already solved important?</p>

<p>Because a journey of a thousand miles begins from a single step. You cannot have a school boy who has just entered college and ask him to solve real life problems which legends have scratched their heads at. We need to start at the base and work our way up. Not only does practicing these problems helps develop one’s interest in algorithms, but at some level concepts like Dynamic Programming, Depth First Search and Graph Theory are what are extrapolated and applied in complex algorithms that boost the cores at Google or Facebook. To put it poetically, unless you know your ABCs you have no hope of finishing a novel. </p>

<p>And that is what PAG hopes to do. It hopes to help the students at R understand these concepts and why it is important for them to do so by bringing them together in a positive competitive environment.Coming together every week to share knowledge, we get to learn so much more than anyone of us individually ever could. Holding regular contests at R and annually on an international scale, keeps everyone motivated to keep doing better. It helps us to learn and strive harder to learn more. </p>

<p><strong>But then, why should you join PAG?</strong></p>

<p>You may be a Grade 2 coder at Topcoder or someone who had no clue about what programming is up till now. It doesn’t matter. As long as you are eager to learn and love working your way around logical and intellectually challenging problems, PAG is looking for you! Every year PAG recruits some of the finest and smartest individuals who come to R. It brings them together in a shared group. There are regular discussions on varied topics of interest, contests are organized and even participated in, and of 
course chapos are given and not to forget the trips we have!!! </p>

<p>Last year a team from PAG qualified for the ACM ICPC World Finals (which happens to be the BIGGEST contest of its kind with participation from over 120 countries) and stood first among all the Indian teams there (and 60th
 overall). We also have several teams who compete in the Regionals of the same contest every year. </p>

<p>And that is the best part about joining PAG! You get to meet so many awesome individuals who you otherwise might not. Bringing like-minded people together who share a common passion helps all of us to learn from each other and improve ourselves. </p>

<p><strong>Recruitment</strong></p>

<p>PAG will be recruiting soon. We are not expecting you to know programming as of now, so if you don’t, it isn’t really an issue. If you have a basic aptitude and the willingness to learn, you are good to go! To stay updated about out recruitment process and other activities, join our <a href="https://www.facebook.com/groups/sdspag/">Facebook group</a> and like our <a href="https://www.facebook.com/sdspag">facebook page</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ DQUERY]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/07/29/spoj-dquery/"/>
    <updated>2013-07-29T15:40:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/07/29/spoj-dquery</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/DQUERY/">Problem</a></strong> :
Given a list of integers, and you need to answer <em>Q</em> queries, in each of which given two indices <em>i</em> and <em>j</em> and you need to answer how many distinct integers are present whose index lies between <em>i</em> and <em>j</em>.</p>

<p><strong>Pre-requisites</strong> : Binary Indexed Trees (For Range Sum Queries), Sorting, Offline Programming</p>

<p><strong>Explanation</strong> :
Let us try to understand the solution for a simpler problem where <em>i</em> = 1 for all queries. Now for every integer if we just mark the first position in the list, for every query the answer will be just the number of integers marked among the first <em>j</em> places.</p>

<p>If we use a boolean array to store the marked integers and run a loop for every query through all the starting j numbers the complexity of the algorithm will be O(N) for each query.</p>

<p>But if we use some advanced data-structure like Binary Indexed Trees, we can acheive this in O(logN) time for every query.
So our final complexity for this simpler problem is O(QlogN).</p>

<p>For our main problem, we need to know a style of programming called <em>Offline Programming</em>.</p>

<p>There are two types of such classification, 
1) Online programming
2) Offline Programming</p>

<p>In online programming we answer each query as soon as we take it as input.</p>

<p>In offline programming we take all the input at once and try to make some changes to the order of input and solve all queries and then print the output for each input in the original order.</p>

<p>For this question we will need to use Offline Programming, where we take all the queries at once and sort them in the ascending order of the left indices <em>i</em>.</p>

<p>Now starting from left i.e, i = 1, we already had the solution of O(Qlog(N)) given above and we will be moving right one by one. Now for solution to all the queries with left index greater than <em>i</em> we just have to ignore the integer at index <em>i</em>. So we will unmark the integer at index <em>i</em>, and mark the left most index to the right of index <em>i</em> whose value is equal to arr[i]. Then we repeat this for index <em>i+1</em>.</p>

<p>This marking and unmarking of the indexes can be acheived in O(log(N)) time using binary indexed trees.</p>

<p>We need the left most index of the integer at index <em>i</em> to mark in the above solution, to acheive this for every index we can check all the integers to the right and store the left most value , but rather we can move from right to left and store present left most index of every integer at every step.(See pseudocode for this) and maintain an array for left most index to the right.</p>

<p>After we get ouput for every input, we will rearrange the input as the original order.</p>

<p><strong>Pseudocode</strong> :</p>

<p>arr[] is the input array</p>

<p>BIT[] stores the marked array.</p>

<p>BIT[i] stores 1 if element is marked or 0 if it is not marked</p>

<p>LMITR[i] stores Left Most Index To Right such that arr[ LMITR[i] ] == arr[i]</p>

<p>PI[] stores the present index of an integer.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Take input
</span><span class="line">
</span><span class="line">loop for i = 1 to 1000000 
</span><span class="line">    PI[i] = INF
</span><span class="line">end loop
</span><span class="line">
</span><span class="line">loop for i = n to 1
</span><span class="line">	LMITR[i] = PI[ arr[i] ]
</span><span class="line">	PI[ arr[i] ] = i
</span><span class="line">end loop
</span><span class="line">
</span><span class="line">loop for i = 1 to n
</span><span class="line">	loop for all queries starting with i
</span><span class="line">		find the sum of first j elements of BIT and store it.
</span><span class="line">	end loop
</span><span class="line">	ummark index i
</span><span class="line">	mark LMITR[i]
</span><span class="line">end loop
</span><span class="line">
</span><span class="line">print output</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ RPSSL]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/07/21/spoj-rpssl/"/>
    <updated>2013-07-21T22:10:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/07/21/spoj-rpssl</id>
    <content type="html"><![CDATA[<p>Problem Link : <a href="http://www.spoj.com/problems/RPSSL/">http://www.spoj.com/problems/RPSSL/</a></p>

<p>Prerequisites : <a href="http://en.wikipedia.org/wiki/Bayes'_theorem">Bayes Theorem</a></p>

<p>Here comes the editorial for <a href="http://www.spoj.com/problems/RPSSL/">previous week’s question</a> as posted on <a href="https://www.facebook.com/groups/sdspag/">our group.</a></p>

<p>Let the probability that Rajesh beats Sheldon in a single round be <script type="math/tex"> w </script> and let <script type="math/tex"> d </script> be the probability that a single round results in a draw and <script type="math/tex"> l </script> be the probability that Sheldon beats Rajesh in a single round. <script type="math/tex"> w ,\ d ,\ l </script> can be calculated simply as follows :</p>

<script type="math/tex; mode=display">

w = R_R*(S_L +S_{Sc}) + R_{Sc}*(S_P + S_L) + R_P*( S_R + S_{Sp}) + R_L*( S_{Sp}+ S_P) + R_{Sp}*( S_R + S_{Sc}) \\

d =  (R_R*S_R) + (R_{Sc}*S_{Sc}) + (R_P*S_P) + (R_L*S_L)+ (R_{Sp}*S_{Sp}) \\
              
l=1-d-w\\         

</script>

<p>Now Rajesh will win the game if he wins two rounds first.
The following are the different cases : </p>

<script type="math/tex; mode=display">

ww \: or \: wdw \: or \: dww \: or \: ddww \: or \: dwdw \: or \: wddw \: ... \\
OR\\
lww \: or \: wlw \: or \: lwdw \: or \: wdlw \: or \: wldw \: ... \\

</script>

<p>Thus we need to sum up all the above cases which result in
victory for rajesh. Both the above series  can be simplified by using some maths tricks. (Refer to <a href="http://en.wikipedia.org/wiki/Arithmetico-geometric_sequence">Arithmetico-geometric series</a>.)</p>

<p>The final expression is :</p>

<script type="math/tex; mode=display">

P = w*w*(1-d)^{-2} + 2*l*w*w*(1-d)^{-3}

</script>

<p><strong>Caution:</strong> Check for the cases where d=1.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Algorithms and Beyond...]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/07/07/algorithms-and-beyond-dot-dot-dot/"/>
    <updated>2013-07-07T15:03:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/07/07/algorithms-and-beyond-dot-dot-dot</id>
    <content type="html"><![CDATA[<p>Here, we present the official blog of one of the recent but very promising student bodies of <a href="http://www.iitr.ac.in/">IIT Roorkee</a> -  <strong>Programming and Algorithms Group</strong>, aka <a href="http://facebook.com/sdspag"><strong>PAG</strong></a>.</p>

<h1 id="about-us">About Us:</h1>

<p>For those who are hearing about us for the first time - PAG is a group of enthusiastic and young programmers spanning across multiple departments, branches and years in IIT Roorkee operating under the aegis of Software Development Section with the aim of improving the algorithmic, mathematical and programatically problem solving capability of students of IIT Roorkee.</p>

<h1 id="why-us">Why Us:</h1>

<p>There is already SDSLabs and IMG in IIT Roorkee, then what is the need of another programming focused student body on campus?</p>

<p>While IMG is mainly concerned with maintaining web applications for the administration, and SDSlabs is innovating and building applications for the web, mobile, network, and so on, there is a strong need of improving the algorithmic and competitive programming capability in the campus. How many people knew about ACM ICPC or TopCoder or CodeChef before PAG came around the corner?
We cater to this very need. We are not just another programming group. The sole objective of this group is to develop a platform where passionate people can learn about algorithms/logic irrespective of their branch.</p>

<h1 id="what-we-do">What We Do:</h1>

<p>The name of the group says it all. Our activities revolve around Programming and Algorithms.</p>

<p>We are people who love to code : A thrill that takes liberties with Logic. Competitive Coding is one of the things that keeps motivated (Damn! Did he solve it faster than me ?? There must be another, faster method!!!)</p>

<p>We organize coding events, we participate in coding events and we win coding events!!! Oh yesss we do all the three things!!!</p>

<p>We also maintain an active <a href="https://www.facebook.com/groups/sdspag/">Facebook group</a> where people can ask us any kind of programming/algorithm related doubt.
 We believe that Programming is not a zero-sum game. Teaching something to a fellow programmer doesn’t take it away from us. We are happy to share what we can, because we are in it for the love of programming. </p>

<p>This blog is another step in this direction where in we will be regularly posting about different algorithms and problems on various online judges. We are also coming up with the concept of <strong>Problem Of The Week</strong> where in we will post a problem every week on our Facebook group and allow people to discuss it and work on it for a week. One week later, before posting the next week’s problem, we will post an editorial about it on our blog. This way we can reach out to more people within and outside IITR.</p>

<p>We are also launching a <a href="http://facebook.com/sdspag">Facebook</a> and a <a href="https://plus.google.com/117727978834269911101">Google+</a> page to share updates about various coding events, algorithms and programming techniques. Follow those pages so that you don’t miss out on anything.</p>

<h1 id="events-by-us">Events by Us:</h1>

<p>Every year we organize a variety of coding events which includes :  </p>

<p><em>Insomnia</em>: Every year during <a href="http://www.cognizance.org.in/">Cognizance</a>, the exclusive Annual Technical Festival of IIT Roorkee, the second largest of its kind in Asia; we organize a fiercely contested online coding contest Insomnia. An overnight contest, which boasts of a huge competition from the world over, including some of the best known names in the field of sport programming, consists problems of ACM style, with varying difficulties covering various topics of algorithmic programming like graph-theory, dynamic programming, sorting, game theory, computational geometry, flows - almost everything. And for the stats, the best team in India could solve only 6 out of the total 14 problems (Insomnia - 2013).</p>

<p>And the team works days and nights, for weeks to rigorously set and test the problems and solutions. We put our best efforts to generate an original and clean problem set, which our participants enjoy to solve. Take a look at last year’s <a href="http://ge.tt/5gEcv6l?c">problem set and editorial</a>.</p>

<p>Here are some glimpses of the event night - those insomniac nights ensuring smooth run:</p>

<p><em>Insomnia’11</em>: 
<img src="http://pag.sdslabs.co/blog//images/posts/Hello-World/11.JPG" /></p>

<p><em>Insomnia’12</em>:
<img src="http://pag.sdslabs.co/blog//images/posts/Hello-World/12.jpg" /></p>

<p><em>Insomnia’13</em>:
<img src="http://pag.sdslabs.co/blog//images/posts/Hello-World/13.JPG" /></p>

<p><em>Codematics</em>: For those who love solving mathematical problems and <strong>not just algorithms</strong> our team organizes Codematics. This event features problems just like Project Euler - Challenging mathematical/computer programming problems that  require more than just maths to solve. Along with maths one has to use his/her programming skills to win. And this too gets participation from all over the world.</p>

<p><em>Bits and Bytes</em>: This event is more of a quiz and involves mathematical and logical puzzles and questions based on implementation details in C/C++/Java</p>

<h1 id="on-campus-activities">On Campus Activities:</h1>

<p>In fact, Insomnia and Codematics are not the only coding contests that PAG organizes. Along with SDSLabs, we are actively involved in organizing several coding contests on intranet at IITR. Known as CodeBlitz, these contests are anticipated by the students at Roorkee who reward us with their active participation. It is one of the several attempts by PAG to improve the coding culture in R-land, and it makes us extremely happy to see our little efforts bear fruit. </p>

<p>We also hold lectures on algorithms for both our members and IITR junta (whose frequency will increase in the coming time). Several teams as well as individuals from PAG participate regularly in programming competitions on almost all popular online judges.</p>

<p>Only few years back IITR was nowhere in the arena of ACM ICPC. There was a severe lack of competitive coding culture in the campus. Few seniors who saw the big picture around, and  with the ambition of improving the culture in campus started this group. </p>

<p>The founders of the group had a dream - <em>To produce an ACM world finalist team from IIT Roorkee</em>. This dream soon became reality.</p>

<p>Two years back we had a team in top 10, one year back we had a team in top 5 and this year for the first time we have the team “The 65th Bit” from IITR that not only qualified for World Finals, ACM ICPC but also scored <a href="http://ahmed-aly.com/ICPC.jsp">best rank</a> among all Indian teams and overall 60th rank, which is held in Russia this year. Only Bombay and Indore were the other IITs among the five Indian teams that qualified (IIIT-Hyderabad and Chennai Mathematical Institute being the other two).</p>

<h1 id="how-we-manage-all-this-">How we manage all this :</h1>

<p><em>CodeRunner</em></p>

<p>We feel proud to host Insomnia as well as other coding events on an in-house developed open-source online judge <a href="https://github.com/shashankkumar/CodeRunner">CodeRunner</a>(developed by SDSLabs), which is similar to <a href="http://spoj.pl">Sphere Online Judge</a>. Currently it supports grading submissions in C, C++, Java, Python,  PHP and Perl with plans for adding more  languages in future.</p>

<p><em>CodeVillage</em>:</p>

<p>CodeVillage is the web application developed and maintained by SDSLabs for hosting the coding events. It is used in all internal coding events as well as in Insomnia 2013.</p>

<p><em>Team</em> : </p>

<p>Every year, PAG recruits some of the best and promising first yearites who enter IIT Roorkee. But this does not mean we lose touch with the graduating students! They stay in touch and guide our group as it takes on new endeavors, providing essential support at every step. To make sure we do not lose out on good talent, the recruitment is a two-step process: a written test followed by a personal interview.</p>

<h1 id="what-else-we-do-">What else we do :</h1>

<p>After working a lot, we enjoy a lot!!! Ohh ya we have our share of fun too. We go on trips and walks, we play football on holidays and we don’t miss out of any reason to have a chapo!!! “Awesome” is not sufficient to describe these. Take some glimpses here:</p>

<p><img src="http://pag.sdslabs.co/blog//images/posts/Hello-World/trip1.JPG" />
<img src="http://pag.sdslabs.co/blog//images/posts/Hello-World/trip2.JPG" />
<img src="http://pag.sdslabs.co/blog//images/posts/Hello-World/trip3.JPG" /></p>

<p>Thats all for now. We will be back soon with a new blog discussing some algorithm or some maths trick  or some coding problem or sharing our own experience with programming. </p>

<p><img src="http://pag.sdslabs.co/blog//images/posts/Hello-World/grp1.jpg" /></p>
]]></content>
  </entry>
  
</feed>
