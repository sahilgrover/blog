<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Binary Indexed Tree | PAG, IIT Roorkee]]></title>
  <link href="http://pag.sdslabs.co/blog//blog/categories/binary-indexed-tree/atom.xml" rel="self"/>
  <link href="http://pag.sdslabs.co/blog//"/>
  <updated>2014-01-07T11:47:41+05:30</updated>
  <id>http://pag.sdslabs.co/blog//</id>
  <author>
    <name><![CDATA[Programming & Algorithms Group, Software Development Section, IIT Roorkee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPOJ-RRSCHED]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/10/03/spoj-rrsched/"/>
    <updated>2013-10-03T18:38:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/10/03/spoj-rrsched</id>
    <content type="html"><![CDATA[<p><strong>Problem</strong> : <a href="http://www.spoj.com/problems/RRSCHED/">RRSCHED</a></p>

<p><strong>Difficulty</strong> : Medium</p>

<p><strong>Prerequisites</strong> : BIT</p>

<p><strong>Explanation</strong> : </p>

<p>A very naive approach would be to iterate over time and keep on decreasing the no of tasks to be performed and storing the task completion time in a separate array.This implementation would definitely give TLE  O(N*T) with the given constraints.</p>

<p>In the above approach we can observe that we can do better by jumping times from t = completion of easiest task (w.r.t time) to t = completion of next easiest task . </p>

<p>For this we need to sort the input array w.r.t time .But we would also want their original indices(because order matters).So you can use pair&lt;int,int&gt;  to store both the index and time  of a task.That way you would not lose your index’s by sorting the array.</p>

<p>In the following discussion:</p>

<p>Pair [i] denotes i th pair in sorted array
Pair[i].Time denotes time needed for ‘Pir[i].Index’ th task to complete.</p>

<p>Now for every iteration all we need to do is to keep track of  Current time and do as follows.</p>

<ol>
  <li>
    <p>Time Taken for present task to be completed
 = 	(no of remaining elements)*(Pair[i].Time-Pair[i-1].Time) +
 		1*no of Tasks before Pair[i].Index which are not completed</p>
  </li>
  <li>
    <p>Extra Time to complete the  round
 = 1*no of Tasks after Pair[i].Index which are not completed.</p>
  </li>
  <li>
    <p>Update Pair[i].Index as completed</p>
  </li>
</ol>

<p>Thus BIT comes in handy here where we have to query the no of tasks not completed and update a task as completed in O(logN). For this purpose initially keep a BIT array and update every element by ‘+1’ which means that the task is not completed yet.You can use Update(i,-1) to update the task as completed. You can find the no of tasks which are not completed  before an index i by Query(i).</p>

<p>The <a href="http://code.hackerearth.com/d8db76J">pesudo code</a> is as follows:</p>

<pre><code>//Initialize bit array to zero 

BIT[MaxN] = 0

// Update bit array 

Upadte(i , x)
	for(; i &lt;= n; i += i&amp;-i)
    	BIT[i] += x

//Query Cummulative Frequency in a bit array 

Query(i)
	s=0
	for(; i&gt;0 ; i-=i&amp;-i)
    	s += BIT[i]
	return s

//Take Input and Do the necessary initializations for BIT array

TakeInput()
for(i = 1; i &lt;= N; i++)
	Update(i, 1)

//Main Part

CurrentTime = 0
for(i = 1; i &lt;= N; i++)

	//N-i+1 total uncompleted tasks
	
	CurrentTime += (Pair[i].Time - Pair[i-1].Time - 1)*(N-i+1)
	
	//query for uncompleted tasks before the present task
	
	CurrentTime +=  Query(Pair[i].Index)
	
	//Store the final anwer for the present task
	
	Answer[Pair[i].Index] = CurrentTime
	
	//Update current task as completed
	
	Update(Pair[i].Index, -1)
	
	//Increase by no of uncompleted tasks after the present task
	
	CurrentTime += (N-i) - Query(Pair[i].Index)

//Note that the above psudo code also handles the case where two tasks have equal completion Time.
</code></pre>

]]></content>
  </entry>
  
</feed>
