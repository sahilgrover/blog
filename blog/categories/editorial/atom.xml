<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Editorial | PAG, IIT Roorkee]]></title>
  <link href="http://pag.sdslabs.co/blog//blog/categories/editorial/atom.xml" rel="self"/>
  <link href="http://pag.sdslabs.co/blog//"/>
  <updated>2014-01-08T15:56:24+05:30</updated>
  <id>http://pag.sdslabs.co/blog//</id>
  <author>
    <name><![CDATA[Programming & Algorithms Group, Software Development Section, IIT Roorkee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPOJ-GEEKOUNT]]></title>
    <link href="http://pag.sdslabs.co/blog//2014/01/08/spoj-geekount/"/>
    <updated>2014-01-08T15:54:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2014/01/08/spoj-geekount</id>
    <content type="html"><![CDATA[<p><a href="www.spoj.com/problems/GEEKOUNT">Problem</a>: Let f(x) be the product of digits of a number. Given L and R, find the number of values of ‘i’ such that L &lt;= i &lt;= R and f(i) is even.  </p>

<p>Pre-Requisites : None</p>

<p>Explanation :</p>

<p>We have to find the count of such numbers, between 2 given numbers, whose product of digits is even. Any number, in which any one digit is even, will come in this category. We will find all those numbers whose product of digits is odd and subtract them from total numbers between two given numbers. We will calculate required numbers from 1 to first number and lets call it num1, then from 1 to second number and lets call it num2 , then num2-num1 will be the answer.</p>

<p>Suppose we consider any n digit number. Then the number of numbers with exactly n digits and all digits odd will be 5 raised to power n. So, the number of numbers from 1 digit to n digits with all digits odd will be sum of all powers of 5 raised to power 1 upto n 
ie. 5^1 + 5^2 + 5^3 +…….+ 5^n.</p>

<p>The above formula of 5 gives the ans as 999..9(n times). But what about the case when the number is neither the smallest, nor the largest n digit number.</p>

<p>So if we are a general n digit number, then we will use formula to calculate the required number of numbers upto n-1 digits and use the following approach to calculate the number of n digits numbers, smaller than given number, for which product of digits is odd.</p>

<p>The number of such numbers will be equal to sum of the numbers of product of half of corresponding digit and 5^ [length-position-1] and  this digit will be from left digit to right digit. However, this process will stop when we encounter an even digit because from there we will not get any number where all digits will be odd.</p>

<p>Pseudocode : </p>

<pre><code>sum[0] = power[0] = 0
for i = 1 to 10 :
    power[i] = power[i-1] * 5 
    sum[i] = sum[i-1] + power[i]
//dig1 is string form of first number.
//dig2 is string form of second number.
//n1 stores the number of numbers whose product of digits is odd.
//length1 is length of first string.
//length2 is length of second string.
n1 = sum[length1-1] 
//Calculating upto length1-1 digits
for j = 0 to length1:
    n1 = n1 + dig1[j]/2 * power[length1-j-1]
// n1 gives the number of numbers with all digits odd from 1 to dig1.
</code></pre>

<p>Do the same for second number.</p>

<p>Subtract n1 from n2 and subtract this result from the difference between the 
given 2 numbers to obtain the required answer.</p>

<p>Let us take an example. Suppose we have to calculate till 57981. So, from 10000 to 50000, our counting will be only from 10000 to 19999 and 30000 to 39999, so and the number will be equal to same which we found for 4-digit numbers. Then we will shift our counter from 5 to 7 in our number 57981. Now, our target will be from 1000 to 1999, 3000 to 3999, 5000 to 5999, and our answer will be same as we found for 3 digit numbers. Process terminates as we encounter 8 as after it, no more numbers with all digits odd.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-COINS]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/12/11/spoj-coins/"/>
    <updated>2013-12-11T19:39:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/12/11/spoj-coins</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/COINS/">Problem</a></strong>: Given, a gold coin in Byteland, find the maximum amount of American dollars you can get for it. </p>

<p><strong>EXPLANATION</strong> :</p>

<p>Consider a golden coin with a number ‘n’ on it. Now, the coin can be exchanged by n/2, n/3, n/4 coins only (all rounded down). Obviously, one would exchange the coins only if n/2+n/3+n/4 is greater than n. And similar holds for n/2, n/3, and n/4 and so on. Looking into the pattern carefully, all the numbers less than 12, if exchanged with coins, would return either lesser or equal to the number. So, it is better to exchange them directly by American dollars (1:1). Let’s try to solve it with a recursive function (a function in which we call our same function to solve it) :</p>

<p><em>Pseudocode of the function</em> :</p>

<p><code>
Return type coin (variable type n)
if(n&lt;12)
	return n;
else
	return summation over i of (maximum of n/i and coin(n/i))
	//here i is 2,3 and 4.
</code></p>

<p>Ok, now an example, say 40:
If I would exchange 40 by coins:-40/2+40/3+40/4=20+13+10=43. But that’s not the correct answer.
20=20/2+20/3+20/4=10+6+5=21
Now, as all the numbers have been reduced to numbers less than 12, they would return the same value.
13=13/2+13/3+13/4=6+4+3=13
10 being lesser than 12 would return the same value. So, 21+13+10= (44) American dollars would be the maximum one can get.</p>

<p>Considering 81:
81/2+81/3+81/4 = 40+27+20
40=20+13+10;
27=13+9+6=28;
20=10+6+5=21;
Correct answer being 93.</p>

<p>Notice that 20 is being tested again (resulting from 40). We thus try to avoid solving a problem (which we have already solved once) again and again. For this we use dynamic programming (or memoization) which is the technique of storing already-calculated values for a fuction in  an array (or vector or some other way) so that we can read those values directly instead of having to solve them again and again.</p>

<p>So, the pseudo code of the function finally becomes:</p>

<p>```
//Here we have used maps. One can use arrays or vectors as well.</p>

<p>static map&lt;variable(n) type, function return type&gt; memo;
if(n&lt;12)
	{return n;}
if(memo.count(n)&gt;0)
	return memo[n];
else
	long long int ret;
	ret= summation over i of (maximum of n/i and coin(n/i));  i=[2,3,4]
	memo[n]=ret;
	return ret;
```</p>

<p>This makes our solution pass well within the time-limit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-PTIME]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/12/11/spoj-ptime/"/>
    <updated>2013-12-11T19:17:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/12/11/spoj-ptime</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/PTIME/">Problem</a></strong>:  To write the prime factorisation of N! (N factorial).</p>

<p><strong>Explanation</strong> :</p>

<p>The prime factorisation of N! would only contain primes less than  or equal to N.  Our main job is to find out the power of each prime factor and then write the prime factorisation in the correct form.</p>

<p>Since the given N is always greater than or equal to 2, its factorial (N!) would have 2 in its prime factorisation. Now let us start by finding the power of 2 in the prime factorisation of N!</p>

<p>N!  =  1*2*3…….(N-2)*(N-1)*N</p>

<p>The number of integers less than or equal to N having a factor of 2 is : Floor(N/2)</p>

<p>Some of the integers would be having more than one 2 in their prime factorisations ( 4 = 2*2, 12 = 2*2*3)
So the number of integers less than or equal to N having a factor of 4 ( 2^2) is : Floor( N/(2^2) )</p>

<p>Similarly the process will continue till 2^i &gt; N.</p>

<p>So the power of 2 in the prime factorisation of N! would be:
 Floor( N/2 ) + Floor( N/(2^2) ) + Floor( N/(2^3)  ) + …….. + Floor( N/(2^i) )                           <br />
                                             where i is the highest number with 2^i &lt;= N</p>

<p>Similarly doing the process for all the prime factors  less than or equal to N, prime factorisation of N! can be obtained where N can be as large as 10000. </p>

<p><em>Pseudocode</em> :</p>

<p><code>
for i = 2 to N
	k = 0
	for a = 2 to sqrt(i)
		if i % a = 0
			k = 1
			exit loop
	if k = 0           // i is prime
		s = 0
		e = N/i
		while e &gt; 0
			s = s + e
			e = e/i
		// after loop completes s would be the power of i in prime factorisation of N!	
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-DCEPC202]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202/"/>
    <updated>2013-11-08T13:33:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/DCEPC202/">Problem</a></strong> :
Given the number of unique shortest paths across a rectangular grid with broken tiles, to find its dimensions.</p>

<p><strong>Pre-requisites</strong> : Principle of inclusion and exclusion, Binary Search</p>

<p><strong>Explanation</strong> :</p>

<p>First consider a corridor of dimension m*n, with no broken tiles. Now, for ‘shortest’ path, you can only move to tiles (x,y+1) or (x+1,y) if you’re currently on tile (x,y). So, to go from (0,0) to (m-1,n-1), you need to move m+n-2 steps with m-1 steps in x direction and n-1 steps in y direction. The number of unique paths will be the number of ways in which you can choose those m-1 (or n-1) steps out of the total m+n steps 
i.e. <sup>(m+n-2)</sup>C<sub>(m-1)</sub></p>

<p>Now, lets take into account the broken tiles:</p>

<p>```
  .<strong>__.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.G
  |    |    |    |    |    |    |
 4|    |    |    | F* |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 3|    |    |    |    |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 2| C <em>|    |    | D</em> |    | E* |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>. 
  |    |    |    |    |    |    |
 1|    |    |    |    |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 0|    |    |    | B *|    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong>__.
 A  0     1        n/2       n-1</p>

<p>```</p>

<p>* represents broken tiles.</p>

<p>Now, employing the principle of inclusion and exclusion, we will first determine the total number of paths and then subtract the number of paths passing through the broken tiles. The total number of paths, therefore, is:</p>

<p>N(AG) - N(AB)*N(BG) - N(AC)*N(CG) - N(AD)*N(DG) - N(AE)*N(EG) - N(AF)*N(FG) + N(AB)*N(BD)*N(DG) + N(AB)*N(BE)*N(EG) + N(AC)*N(CD)*N(DG) + N(AC)*N(CF)*N(FG) + N(AD)*N(DE)*N(EG) + N(AD)*N(DF)*N(FG) - N(AB)*N(BD)*N(DF)*N(FG) - N(AC)*N(CD)*N(DE)*N(EG)</p>

<p>where:</p>

<p>N(AG)= <sup>(n - 1 + 4)</sup>C<sub>4</sub> = p</p>

<p>N(AF)= <sup>(n/2 + 4)</sup>C<sub>4</sub> = q</p>

<p>N(AE)=N(CG)= <sup>(n-1+2)</sup>C<sub>2</sub> = r</p>

<p>N(BG)= <sup>(n - 1 - n/2 + 4)</sup>C<sub>4</sub> = s</p>

<p>N(AD)=N(CF)= <sup>(n/2 + 2)</sup>C<sub>2</sub> = t</p>

<p>N(BE)=N(DG)= <sup>(n - 1 - n/2 + 2)</sup>C<sub>2</sub> = u</p>

<p>N(AB)=N(AC)=N(BD)=N(CD)=N(DE)=N(DF)=N(EG)=N(FG)=1</p>

<p>So, the final expression for number of unique paths, k is:</p>

<p>k = p - 1*s - 1*r - t*u - r*1 - q*1 + 1*1*u + 1*u*1 + 1*1*u + 1*t*1 + t*1*1 + t*1*1 - 1 - 1</p>

<p>=&gt;  k = p - s - 2*r - t*u -q + 3*u + 3*t -2</p>

<p>According to the problem, we have to find out the dimension of the corridor i.e. n for a given k. For this we will make an array of the k values of all 1&lt;=n&lt;=10000 beforehand. Now for each k, we’ll carry out a binary search in the array to find out the value of n for which no. of paths is equal to or just larger than k.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-DGAME]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/10/18/spoj-dgame/"/>
    <updated>2013-10-18T21:16:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/10/18/spoj-dgame</id>
    <content type="html"><![CDATA[<p><strong>Prerequisites</strong> :  Game of Nim</p>

<p><strong><a href="http://www.spoj.com/problems/DGAME/">Problem</a></strong> : Game of Nim with variations. (N piles with i<sup>th</sup> pile containing either 2<em>i or 2</em>i+1 stones where even number of stones may be removed from selected pile.)</p>

<p><strong>Explanation</strong> :</p>

<p>At every index i, can have stones in two ways, so total no. of ways comes out to be 2 * 2 * . . . . * 2 (n times).</p>

<p>Now whether an index have 2<em>i or 2</em>i+1 stones the game remains unaffected because if there are 2<em>i+1 stones in any pile there will be one stone left out anyways, and the game will be same as the one played with 2</em>i stones. We shall be considering only this case.</p>

<p>At any point of the game i<sup>th</sup> pile contains 2*(i - k) stones (where k is any arbitrary constant). Now you can interpret the question as the ith pile had i stones in the beginning and you can take out any positive number of stones from it. This is the standard nim game containing N piles, where the ith pile contains i stones.</p>

<p>Now our task is to find XOR of N numbers(1 to N). Every number can be represented 4*p+q where 0 &lt;= q &lt;= 3 and p is any arbitrary.</p>

<p>For every N of type 4*p+3, it can be easily proved that XOR of 1 to N is 0. So the first person will always lose the game. The answer for such numbers is zero.</p>

<p>For N of type 4*p+1 XOR of numbers from 1 to N is 1, so the first player can remove 1 stone from any pile containing odd number of stones so that the XOR becomes zero. There are (N+1)/2 piles containing odd number of stones, so the answer for this case is (N+1)/2.</p>

<p>For numbers of type 4<em>p or 4</em>p+2 XOR is N and N+1 respectively So first player can make XOR zero by removing stones from any pile whose most significant bit is same as the most significant bit of N. Thus the answer for this case is the number of piles which has x stones, such that when x is represented in binary, it has the same number of bits as the binary representation of N. This can be obtained by subtracting from N the maximum power of 2 which is less than or equal to N.</p>

<p><strong>Links</strong> : <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=algorithmGames">Game of Nim</a></p>
]]></content>
  </entry>
  
</feed>
