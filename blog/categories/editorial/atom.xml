<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Editorial | PAG, IIT Roorkee]]></title>
  <link href="http://pag.sdslabs.co/blog//blog/categories/editorial/atom.xml" rel="self"/>
  <link href="http://pag.sdslabs.co/blog//"/>
  <updated>2013-09-16T20:26:17+05:30</updated>
  <id>http://pag.sdslabs.co/blog//</id>
  <author>
    <name><![CDATA[Programming & Algorithms Group, Software Development Section, IIT Roorkee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPOJ MORSE]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/09/16/spoj-morse/"/>
    <updated>2013-09-16T18:30:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/09/16/spoj-morse</id>
    <content type="html"><![CDATA[<p><strong>Prerequisites</strong> : Dynamic Programming.</p>

<p><strong><a href="http://www.spoj.com/problems/MORSE/">Problem</a></strong> : </p>

<p>Given the Morse code for English alphabet, a list of words(dictionary) and a Morse sequence, the task is to compute the number of distinct phrases that can be obtained from the sequence using words from the dictionary.</p>

<p><strong>Explanation</strong> :</p>

<p>In this problem, we are given N words in a dictionary and a Morse string containing ‘.’ and ‘-’ of length L. Now we are asked to find how many strings from the dictionary words when converted to their Morse part will exactly map to the given Morse sequence.</p>

<p>Say we have .-..–.-..-.-…- and the dictionary as a aa bc acm shuka etc., one naive way is to generate all possible strings using the given words of the dictionary and see if they map to the given Morse string or not. But this approach is too slow and can take centuries to calculate if number of letters in dictionary are large enough (O(L<sup>N</sup>)).</p>

<p>So, one thing to observe here is there will be several sub-cases counted a lot more times than required as in sub part of Morse string ‘.-..-’ might map to one english string and the rest part of Morse string doesn’t, so for calculating that this isn’t a valid string will itself take order O(L^N) time. </p>

<p>Such problems where only number of solutions are to be found are approached as given:</p>

<ol>
  <li>Start iterating Morse string either from left or right.</li>
  <li>At each point,check if the current string covered using the iterator maps to any word in the dictionary(So this iteration is finding the last(or first) word that could be placed from dictionary to the position of the iterator).</li>
  <li>When a word is found,use recursion on the remaining string.</li>
</ol>

<p>Here we were also given some constraints to help us out with our complexity analysis:</p>

<ol>
  <li>Length of Morse string : 10000</li>
  <li>Length of a word : 20</li>
  <li>Number of words in the dictionary : 10000 </li>
</ol>

<p>The pseudocode of the above idea looks something like :</p>

<pre><code>    Function TotalStrings(int i) //the current position of the iterator
	{

		for(k from i to Morselength) // Morselength stores the length of the Morse string
		{

			if string[i…k] is valid and in dictionary
			then answer = answer + TotalStrings(k)

		}
	   
		return answer;

	}
</code></pre>

<p>Disclaimer: The below arguments are assuming we can search a Morse in a dictionary in O(1) time.</p>

<p>The above solution still doesn’t seem to ease our problem as we still have to face the worst case time complexity as O(L^N) but whenever we find some repeating subproblems we should always think of Dynamic Programming.</p>

<p>Now the question is: What if in the above code, the value TotalStrings(k) was already known to us? In that case what would the time complexity be?</p>

<p>It will be linear if all values of TotalStrings(k) are pre-known. Here comes the concept of Dynamic programming in which we can store the values of TotalStrings(k) whenever we calculate it. As we use linear time for calculating all the TotalStrings(k) with k in (0,Morselength),we use a total of O(L^2) time where L is the length of the Morse string.</p>

<p>All we need to change in code is before returning answer, just store the answer calculated in some global array so that next time the same value is asked it could be returned immediately.</p>

<p>Now,taking advantage of the constraints :</p>

<p>Length of a word cannot exceed 20 as given in the question,hence the conclusions are :</p>

<ol>
  <li>Each alphabet can have maximum 4 ‘.’ or ’-‘ characters. So a word of length 20 can have maximum 80 Morse characters</li>
  <li>Hence in the inner loop of the above pseudo code k varies from i to i+80</li>
  <li>If the word searching is extremely fast, our complexity reduces to O(80*l)</li>
</ol>

<p>The problem left now is word searching. We can think of various methods and techniques to find a map from dictionary to the iterated part being used.</p>

<ol>
  <li>Hash maps</li>
  <li>STL library map</li>
  <li>Brute force</li>
  <li>Trie implementation</li>
</ol>

<p>Of all the above methods,the most reliable for this problem is trie, given the constraints and the difficulty in using large length strings(~80).</p>

<p>Trie implementation is simple and can be performed using arrays as well as link lists.</p>

<p><strong>Links</strong> :</p>

<p><a href="http://www.geeksforgeeks.org/trie-insert-and-search/">http://www.geeksforgeeks.org/trie-insert-and-search/</a></p>

<p><a href="http://en.wikipedia.org/wiki/Trie">http://en.wikipedia.org/wiki/Trie</a></p>

<p><strong>Related problem on trie</strong> :</p>

<p><a href="http://www.spoj.com/problems/REVFIB/">SPOJ-REVFIB</a> (Difficulty Level: Hard)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ NACCI]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/08/28/spoj-nacci/"/>
    <updated>2013-08-28T20:00:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/08/28/spoj-nacci</id>
    <content type="html"><![CDATA[<p>Prerequisites : Matrix Exponentation.</p>

<p><a href="http://www.spoj.com/problems/NACCI/">Problem</a> : </p>

<p>Find f[M] such that if (M &gt; N) f[M] = sum(f[M - i]) for(i = 1 to N) else f[M] = M.</p>

<p>Explanation :</p>

<p>For convenience let us take k = 4. So f[n] = f[n - 1] + f[n - 2] + f[n - 3] + f[n - 4].
Let us consider two matrices A,B of size (4 X 4)</p>

<p>Matrix A :</p>

<pre><code>{ f[i]  f[i - 1]  f[i - 2] f[i - 3] }
{  0        0        0         0    }
{  0        0        0         0    }
{  0        0        0         0    }
</code></pre>

<p>Matrix B :</p>

<pre><code>{ 1   1   0   0 }
{ 1   0   1   0 }
{ 1   0   0   1 }
{ 1   0   0   0 }
</code></pre>

<p>MAtrix A X B :</p>

<pre><code>{ (f[i]+f[i-1]+f[i-2]+f[i-3]   f[i]   f[i - 1]   f[i - 2] }
{  0                             0        0         0     }
{  0                             0        0         0     }
{  0                             0        0         0     }
</code></pre>

<p>That will be equal to</p>

<pre><code>{ (f[i+1]   f[i]   f[i - 1]   f[i - 2] }
{    0        0        0         0     }
{    0        0        0         0     }
{    0        0        0         0     }		
</code></pre>

<p>So multiplying matrix A by matrix B by p times leaves f[i+p] in the first row first column position.
Let initially Matrix A be</p>

<pre><code>{ f[3]     f[2]     f[1]    f[0] }
{  0        0        0       0   }
{  0        0        0       0   }
{  0        0        0       0   }
</code></pre>

<p>So Multiplying A with B by p times leaves f[3+p] in the first row first column element of product matrix.</p>

<p>To get M’th element we just need to multiply A with B by M - 3 times. As M is very large we can calculate this my repeated squaring in O(logM) multiplications. For a (N X N) matrix as each matrix multiplication takes O(N^3) steps overall complexity becomes O(log(M)*(N^3)).</p>

<p>For an (N X N) matrix, B might look as </p>

<p>Matrix B :</p>

<pre><code>{ 1  1  0  0  0 ...}
{ 1  0  1  0  0 ...}
{ 1  0  0  1  0 ...}
{ 1  0  0  0  1 ...}  
{ .................}
</code></pre>

<p>(So on till N rows N columns)</p>

<p>To be generalized let b(i,j) be i’th row j’th column element of matrix. Then b(i,j) = 1 if (j == 0) or (j == i + 1)
In general any linear equation of above type like f[n] = a1<em>f[n - 1] + a2</em>f[n - 2] + … can be solved by making B[i][0] = ai for all (i = 0 to N - 1)</p>

<p>PseudoCode :</p>

<pre><code>int[][] MatrixMul(int[][] A, int[][] B)

	int[][] P;

	int i,j,k;

    for(k = 0 to n - 1)

	    for(i = 0 to n - 1)
	
    	    for(j = 0 to n - 1)
		
        	    P[i][j] += A[i][k] * B[k][j]
		
        	end loop
	
	    end loop

	end loop

	return P

end MatrixMul


int[][] PowerMatrix(int[][] B , power) :

	if(power == 1) :
	
    	return B

	else

    	int[][] temp = PowerMatrix(B , power / 2) 
	
    	temp = MatrixMul(temp,temp)
	
	    if(power % 2 == 1) :
	
    	    temp = MatrixMul(temp,B)
	
	    end if
	
    	return temp

	end ifelse

end PowerMatrix


int NACCI(int M , int N) :

	if M &lt; N
	
    	return M
	else

    	int A[N][N],B[N][N],i,j;
	
    	for(j = 0 to N - 1)
	
        	A[0][j] = N - 1 - j
    
   	 	end loop
	
	    for(i = 1 to N - 1)
		
    	    for(j = 0 to N - 1)
		
        	    A[i][j] = 0
		
       		end loop
	
    	end loop
	
    	for(i = 0 to N - 1)
	
        	B[i][0] = 1
		
        	for(j = 1 to N - 1)
		
	            if (j == i + 1)
			
    	            B[i][j] = 1
			
        	    else 
			
            	    B[i][j] = 0
			
            	end ifelse
		
        	end loop

    	end loop
	
	    A = MatrixMul( A , PowerMatrix(B,M - N + 1) )
	
    	retrurn A[0][0]

	end ifelse

end NACCI
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-TREZOR]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/08/21/spoj-trezor/"/>
    <updated>2013-08-21T00:29:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/08/21/spoj-trezor</id>
    <content type="html"><![CDATA[<p><a href="http://www.spoj.com/problems/TREZOR/">Problem</a> :</p>

<p>Given a 2-D Coordinate Plane, find how many points are visible from one point. Two persons are standing at two other points, and you need to find how many other points are visible to both, points visible to only one, and none.</p>

<p>Explanation:</p>

<p>For Simplicity consider one guard standing at <strong>(0,0)</strong> and rectangle of size <strong>L*(A+B+1)</strong> is present with corner points <strong>(1,0) (L,0) (1,A+B) (L,A+B)</strong> and other guard is standing at <strong>(0,A+B)</strong>.</p>

<p>Lets discuss the solution to one guard. A point <strong>(X,Y)</strong> will be blocked by another point <strong>(X1,Y1)</strong> to the origin if the slopes of lines joining points are equal, i.e <strong>X / X1 = Y / Y1 = Z (Z &gt; 1)</strong>. That means <strong>X = X1 * Z</strong> and <strong>Y = Y1 * Z</strong>, which inturn means that <strong>X</strong> and <strong>Y</strong> are not coprimes (have a common factor). So for every horizontal row <strong>(i,Y)</strong> number of points visible to origin are number of <strong>i’s</strong> from <strong>1 to L</strong> that are coprime to <strong>Y</strong>.</p>

<p>Similar is the situation to other guard, points of the form <strong>(i,Y)</strong> are visible if and only if <strong>‘i’</strong> is coprime to <strong>(A+B-Y)</strong>. and visible to both if <strong>‘i’</strong> is coprime to <strong>(A+B-Y)</strong> and <strong>Y</strong>, which means <strong>‘i’</strong> is coprime to <strong>(A+B-Y)*Y</strong>..</p>

<p>Now the problem is reduced for a given <strong>Y</strong> , how many numbers from <strong>1 to L</strong> are coprime to <strong>Y</strong>. For this we can prime factorize <strong>Y</strong> and use inclusion and exclusion principle on primes to find the final answer. Total there can be at max 6 prime factors to <strong>Y</strong>, as the product of first six primes  &gt; 4000 = <strong>(A+B)</strong>. Now it takes <strong>2^N = (2^6) = 64</strong> steps for finding number of coprimes of each Y, so 3 * 64 for each horizontal row, so (3 * 64 * 4000) for all rows  = 768000 steps which comes under time limit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ MBALL]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/08/05/spoj-mball/"/>
    <updated>2013-08-05T15:26:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/08/05/spoj-mball</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/MBALL/">Problem</a></strong> :
Given the possible ways of scoring in a game, you neeed to find in how many ways can a given score be achieved.</p>

<p><strong>Pre-requisites</strong> : <a href="http://www.topcoder.com/tc?d1=tutorials&amp;d2=dynProg&amp;module=Static">Dynamic Programming</a>(read DP)</p>

<p><strong>Explanation</strong> :</p>

<p>The problem is quite simple. The different ways of scoring can be as follows:</p>

<ul>
  <li>safety: 2 points</li>
  <li>field goal: 3 points</li>
  <li>touchdown: 6 points</li>
  <li>one-point conversion try after touchdown: 7 points</li>
  <li>two-point conversion try after touchdown: 8 points</li>
</ul>

<p>We start by subtracting the smallest possible score ie 2 from the given score and reduce it to smaller instance of the same problem. This way we continue till we reach 0. Then carry out this step with 3,6,7and 8 as well.</p>

<p>eg 10 points can be scored in following ways:</p>

<ul>
  <li>first 2 points and then scoring 8 points.
    <ul>
      <li>2 points can be scored in 1 way only and 8 points can be scored in following way:
        <ul>
          <li>first 2 points and then 6 points.</li>
          <li>first 3 points and then 5 points.</li>
          <li>first 4 points and then 4 points.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>first 3 points and then scoring 7 points.</li>
  <li>first 4 points and then scoring 6 points.</li>
  <li>first 5 points and then scoring 5 points.</li>
</ul>

<p>In each case we reduce the problem to a subproblem of the same type.</p>

<p>Notice a pitfall here. Even if there is just one test case (say S=10 itself), We are doing the computation for various subproblems again and again. eg we calculate the number of ways of scoring 6 points when we are calculating the number of ways of scoring 8 points. And we are doing this calculation again when we try to find number of ways scoring 10 points. </p>

<p>Basically we are solving the same sub problem again and again even when we have just one test case. Surely this method will timeeout. </p>

<p>So what do we do? We use DP. DP means we save the result of various sub problems so that we do not have to calculate them again and again. In this case, we make an array called <em>result[N]</em> (and initialise with -1) in which we store the number of ways of achieving <em>i</em> score for all <em>i</em> varying from 2 to <em>N</em>. Also there is only one way of achieving score of ‘0’. So <em>result[0]</em>=1. Now when we need to calcualte the number of ways of achieving score <em>i</em>, we check the array. If it contains -1, we calculate the result and update the array entry else we use the value from the array.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ DQUERY]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/07/29/spoj-dquery/"/>
    <updated>2013-07-29T15:40:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/07/29/spoj-dquery</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/DQUERY/">Problem</a></strong> :
Given a list of integers, and you need to answer <em>Q</em> queries, in each of which given two indices <em>i</em> and <em>j</em> and you need to answer how many distinct integers are present whose index lies between <em>i</em> and <em>j</em>.</p>

<p><strong>Pre-requisites</strong> : Binary Indexed Trees (For Range Sum Queries), Sorting, Offline Programming</p>

<p><strong>Explanation</strong> :
Let us try to understand the solution for a simpler problem where <em>i</em> = 1 for all queries. Now for every integer if we just mark the first position in the list, for every query the answer will be just the number of integers marked among the first <em>j</em> places.</p>

<p>If we use a boolean array to store the marked integers and run a loop for every query through all the starting j numbers the complexity of the algorithm will be O(N) for each query.</p>

<p>But if we use some advanced data-structure like Binary Indexed Trees, we can acheive this in O(logN) time for every query.
So our final complexity for this simpler problem is O(QlogN).</p>

<p>For our main problem, we need to know a style of programming called <em>Offline Programming</em>.</p>

<p>There are two types of such classification, 
1) Online programming
2) Offline Programming</p>

<p>In online programming we answer each query as soon as we take it as input.</p>

<p>In offline programming we take all the input at once and try to make some changes to the order of input and solve all queries and then print the output for each input in the original order.</p>

<p>For this question we will need to use Offline Programming, where we take all the queries at once and sort them in the ascending order of the left indices <em>i</em>.</p>

<p>Now starting from left i.e, i = 1, we already had the solution of O(Qlog(N)) given above and we will be moving right one by one. Now for solution to all the queries with left index greater than <em>i</em> we just have to ignore the integer at index <em>i</em>. So we will unmark the integer at index <em>i</em>, and mark the left most index to the right of index <em>i</em> whose value is equal to arr[i]. Then we repeat this for index <em>i+1</em>.</p>

<p>This marking and unmarking of the indexes can be acheived in O(log(N)) time using binary indexed trees.</p>

<p>We need the left most index of the integer at index <em>i</em> to mark in the above solution, to acheive this for every index we can check all the integers to the right and store the left most value , but rather we can move from right to left and store present left most index of every integer at every step.(See pseudocode for this) and maintain an array for left most index to the right.</p>

<p>After we get ouput for every input, we will rearrange the input as the original order.</p>

<p><strong>Pseudocode</strong> :</p>

<p>arr[] is the input array</p>

<p>BIT[] stores the marked array.</p>

<p>BIT[i] stores 1 if element is marked or 0 if it is not marked</p>

<p>LMITR[i] stores Left Most Index To Right such that arr[ LMITR[i] ] == arr[i]</p>

<p>PI[] stores the present index of an integer.</p>

<p>```
Take input</p>

<p>loop for i = 1 to 1000000 
    PI[i] = INF
end loop</p>

<p>loop for i = n to 1
	LMITR[i] = PI[ arr[i] ]
	PI[ arr[i] ] = i
end loop</p>

<p>loop for i = 1 to n
	loop for all queries starting with i
		find the sum of first j elements of BIT and store it.
	end loop
	ummark index i
	mark LMITR[i]
end loop</p>

<p>print output
```</p>
]]></content>
  </entry>
  
</feed>
