<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Binary Search | PAG, IIT Roorkee]]></title>
  <link href="http://pag.sdslabs.co/blog//blog/categories/binary-search/atom.xml" rel="self"/>
  <link href="http://pag.sdslabs.co/blog//"/>
  <updated>2014-05-17T12:51:47+05:30</updated>
  <id>http://pag.sdslabs.co/blog//</id>
  <author>
    <name><![CDATA[Programming & Algorithms Group, Software Development Section, IIT Roorkee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPOJ-DCEPC202]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202/"/>
    <updated>2013-11-08T13:33:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/DCEPC202/">Problem</a></strong> :
Given the number of unique shortest paths across a rectangular grid with broken tiles, to find its dimensions.</p>

<p><strong>Pre-requisites</strong> : Principle of inclusion and exclusion, Binary Search</p>

<p><strong>Explanation</strong> :</p>

<p>First consider a corridor of dimension m*n, with no broken tiles. Now, for ‘shortest’ path, you can only move to tiles (x,y+1) or (x+1,y) if you’re currently on tile (x,y). So, to go from (0,0) to (m-1,n-1), you need to move m+n-2 steps with m-1 steps in x direction and n-1 steps in y direction. The number of unique paths will be the number of ways in which you can choose those m-1 (or n-1) steps out of the total m+n steps 
i.e. <sup>(m+n-2)</sup>C<sub>(m-1)</sub></p>

<p>Now, lets take into account the broken tiles:</p>

<p>```
  .<strong>__.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.G
  |    |    |    |    |    |    |
 4|    |    |    | F* |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 3|    |    |    |    |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 2| C <em>|    |    | D</em> |    | E* |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>. 
  |    |    |    |    |    |    |
 1|    |    |    |    |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 0|    |    |    | B *|    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong>__.
 A  0     1        n/2       n-1</p>

<p>```</p>

<p>* represents broken tiles.</p>

<p>Now, employing the principle of inclusion and exclusion, we will first determine the total number of paths and then subtract the number of paths passing through the broken tiles. The total number of paths, therefore, is:</p>

<p>N(AG) - N(AB)*N(BG) - N(AC)*N(CG) - N(AD)*N(DG) - N(AE)*N(EG) - N(AF)*N(FG) + N(AB)*N(BD)*N(DG) + N(AB)*N(BE)*N(EG) + N(AC)*N(CD)*N(DG) + N(AC)*N(CF)*N(FG) + N(AD)*N(DE)*N(EG) + N(AD)*N(DF)*N(FG) - N(AB)*N(BD)*N(DF)*N(FG) - N(AC)*N(CD)*N(DE)*N(EG)</p>

<p>where:</p>

<p>N(AG)= <sup>(n - 1 + 4)</sup>C<sub>4</sub> = p</p>

<p>N(AF)= <sup>(n/2 + 4)</sup>C<sub>4</sub> = q</p>

<p>N(AE)=N(CG)= <sup>(n-1+2)</sup>C<sub>2</sub> = r</p>

<p>N(BG)= <sup>(n - 1 - n/2 + 4)</sup>C<sub>4</sub> = s</p>

<p>N(AD)=N(CF)= <sup>(n/2 + 2)</sup>C<sub>2</sub> = t</p>

<p>N(BE)=N(DG)= <sup>(n - 1 - n/2 + 2)</sup>C<sub>2</sub> = u</p>

<p>N(AB)=N(AC)=N(BD)=N(CD)=N(DE)=N(DF)=N(EG)=N(FG)=1</p>

<p>So, the final expression for number of unique paths, k is:</p>

<p>k = p - 1*s - 1*r - t*u - r*1 - q*1 + 1*1*u + 1*u*1 + 1*1*u + 1*t*1 + t*1*1 + t*1*1 - 1 - 1</p>

<p>=&gt;  k = p - s - 2*r - t*u -q + 3*u + 3*t -2</p>

<p>According to the problem, we have to find out the dimension of the corridor i.e. n for a given k. For this we will make an array of the k values of all 1&lt;=n&lt;=10000 beforehand. Now for each k, we’ll carry out a binary search in the array to find out the value of n for which no. of paths is equal to or just larger than k.</p>
]]></content>
  </entry>
  
</feed>
