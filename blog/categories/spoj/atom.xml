<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SPOJ | PAG, IIT Roorkee]]></title>
  <link href="http://pag.sdslabs.co/blog//blog/categories/spoj/atom.xml" rel="self"/>
  <link href="http://pag.sdslabs.co/blog//"/>
  <updated>2013-12-22T14:30:58+05:30</updated>
  <id>http://pag.sdslabs.co/blog//</id>
  <author>
    <name><![CDATA[Programming & Algorithms Group, Software Development Section, IIT Roorkee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPOJ-COINS]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/12/11/spoj-coins/"/>
    <updated>2013-12-11T19:39:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/12/11/spoj-coins</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/COINS/">Problem</a></strong>: Given, a gold coin in Byteland, find the maximum amount of American dollars you can get for it. </p>

<p><strong>EXPLANATION</strong> :</p>

<p>Consider a golden coin with a number ‘n’ on it. Now, the coin can be exchanged by n/2, n/3, n/4 coins only (all rounded down). Obviously, one would exchange the coins only if n/2+n/3+n/4 is greater than n. And similar holds for n/2, n/3, and n/4 and so on. Looking into the pattern carefully, all the numbers less than 12, if exchanged with coins, would return either lesser or equal to the number. So, it is better to exchange them directly by American dollars (1:1). Let’s try to solve it with a recursive function (a function in which we call our same function to solve it) :</p>

<p><em>Pseudocode of the function</em> :</p>

<p><code>
Return type coin (variable type n)
if(n&lt;12)
	return n;
else
	return summation over i of (maximum of n/i and coin(n/i))
	//here i is 2,3 and 4.
</code></p>

<p>Ok, now an example, say 40:
If I would exchange 40 by coins:-40/2+40/3+40/4=20+13+10=43. But that’s not the correct answer.
20=20/2+20/3+20/4=10+6+5=21
Now, as all the numbers have been reduced to numbers less than 12, they would return the same value.
13=13/2+13/3+13/4=6+4+3=13
10 being lesser than 12 would return the same value. So, 21+13+10= (44) American dollars would be the maximum one can get.</p>

<p>Considering 81:
81/2+81/3+81/4 = 40+27+20
40=20+13+10;
27=13+9+6=28;
20=10+6+5=21;
Correct answer being 93.</p>

<p>Notice that 20 is being tested again (resulting from 40). We thus try to avoid solving a problem (which we have already solved once) again and again. For this we use dynamic programming (or memoization) which is the technique of storing already-calculated values for a fuction in  an array (or vector or some other way) so that we can read those values directly instead of having to solve them again and again.</p>

<p>So, the pseudo code of the function finally becomes:</p>

<p>```
//Here we have used maps. One can use arrays or vectors as well.</p>

<p>static map&lt;variable(n) type, function return type&gt; memo;
if(n&lt;12)
	{return n;}
if(memo.count(n)&gt;0)
	return memo[n];
else
	long long int ret;
	ret= summation over i of (maximum of n/i and coin(n/i));  i=[2,3,4]
	memo[n]=ret;
	return ret;
```</p>

<p>This makes our solution pass well within the time-limit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-PTIME]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/12/11/spoj-ptime/"/>
    <updated>2013-12-11T19:17:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/12/11/spoj-ptime</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/PTIME/">Problem</a></strong>:  To write the prime factorisation of N! (N factorial).</p>

<p><strong>Explanation</strong> :</p>

<p>The prime factorisation of N! would only contain primes less than  or equal to N.  Our main job is to find out the power of each prime factor and then write the prime factorisation in the correct form.</p>

<p>Since the given N is always greater than or equal to 2, its factorial (N!) would have 2 in its prime factorisation. Now let us start by finding the power of 2 in the prime factorisation of N!</p>

<p>N!  =  1*2*3…….(N-2)*(N-1)*N</p>

<p>The number of integers less than or equal to N having a factor of 2 is : Floor(N/2)</p>

<p>Some of the integers would be having more than one 2 in their prime factorisations ( 4 = 2*2, 12 = 2*2*3)
So the number of integers less than or equal to N having a factor of 4 ( 2^2) is : Floor( N/(2^2) )</p>

<p>Similarly the process will continue till 2^i &gt; N.</p>

<p>So the power of 2 in the prime factorisation of N! would be:
 Floor( N/2 ) + Floor( N/(2^2) ) + Floor( N/(2^3)  ) + …….. + Floor( N/(2^i) )                           <br />
                                             where i is the highest number with 2^i &lt;= N</p>

<p>Similarly doing the process for all the prime factors  less than or equal to N, prime factorisation of N! can be obtained where N can be as large as 10000. </p>

<p><em>Pseudocode</em> :</p>

<p><code>
for i = 2 to N
	k = 0
	for a = 2 to sqrt(i)
		if i % a = 0
			k = 1
			exit loop
	if k = 0           // i is prime
		s = 0
		e = N/i
		while e &gt; 0
			s = s + e
			e = e/i
		// after loop completes s would be the power of i in prime factorisation of N!	
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-DCEPC202]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202/"/>
    <updated>2013-11-08T13:33:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/11/08/spoj-dcepc202</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.spoj.com/problems/DCEPC202/">Problem</a></strong> :
Given the number of unique shortest paths across a rectangular grid with broken tiles, to find its dimensions.</p>

<p><strong>Pre-requisites</strong> : Principle of inclusion and exclusion, Binary Search</p>

<p><strong>Explanation</strong> :</p>

<p>First consider a corridor of dimension m*n, with no broken tiles. Now, for ‘shortest’ path, you can only move to tiles (x,y+1) or (x+1,y) if you’re currently on tile (x,y). So, to go from (0,0) to (m-1,n-1), you need to move m+n-2 steps with m-1 steps in x direction and n-1 steps in y direction. The number of unique paths will be the number of ways in which you can choose those m-1 (or n-1) steps out of the total m+n steps 
i.e. <sup>(m+n-2)</sup>C<sub>(m-1)</sub></p>

<p>Now, lets take into account the broken tiles:</p>

<p>```
  .<strong>__.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.G
  |    |    |    |    |    |    |
 4|    |    |    | F* |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 3|    |    |    |    |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 2| C <em>|    |    | D</em> |    | E* |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>. 
  |    |    |    |    |    |    |
 1|    |    |    |    |    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.
  |    |    |    |    |    |    |
 0|    |    |    | B *|    |    |
  .</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong><strong>.</strong>__.
 A  0     1        n/2       n-1</p>

<p>```</p>

<p>* represents broken tiles.</p>

<p>Now, employing the principle of inclusion and exclusion, we will first determine the total number of paths and then subtract the number of paths passing through the broken tiles. The total number of paths, therefore, is:</p>

<p>N(AG) - N(AB)*N(BG) - N(AC)*N(CG) - N(AD)*N(DG) - N(AE)*N(EG) - N(AF)*N(FG) + N(AB)*N(BD)*N(DG) + N(AB)*N(BE)*N(EG) + N(AC)*N(CD)*N(DG) + N(AC)*N(CF)*N(FG) + N(AD)*N(DE)*N(EG) + N(AD)*N(DF)*N(FG) - N(AB)*N(BD)*N(DF)*N(FG) - N(AC)*N(CD)*N(DE)*N(EG)</p>

<p>where:</p>

<p>N(AG)= <sup>(n - 1 + 4)</sup>C<sub>4</sub> = p</p>

<p>N(AF)= <sup>(n/2 + 4)</sup>C<sub>4</sub> = q</p>

<p>N(AE)=N(CG)= <sup>(n-1+2)</sup>C<sub>2</sub> = r</p>

<p>N(BG)= <sup>(n - 1 - n/2 + 4)</sup>C<sub>4</sub> = s</p>

<p>N(AD)=N(CF)= <sup>(n/2 + 2)</sup>C<sub>2</sub> = t</p>

<p>N(BE)=N(DG)= <sup>(n - 1 - n/2 + 2)</sup>C<sub>2</sub> = u</p>

<p>N(AB)=N(AC)=N(BD)=N(CD)=N(DE)=N(DF)=N(EG)=N(FG)=1</p>

<p>So, the final expression for number of unique paths, k is:</p>

<p>k = p - 1*s - 1*r - t*u - r*1 - q*1 + 1*1*u + 1*u*1 + 1*1*u + 1*t*1 + t*1*1 + t*1*1 - 1 - 1</p>

<p>=&gt;  k = p - s - 2*r - t*u -q + 3*u + 3*t -2</p>

<p>According to the problem, we have to find out the dimension of the corridor i.e. n for a given k. For this we will make an array of the k values of all 1&lt;=n&lt;=10000 beforehand. Now for each k, we’ll carry out a binary search in the array to find out the value of n for which no. of paths is equal to or just larger than k.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-DGAME]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/10/18/spoj-dgame/"/>
    <updated>2013-10-18T21:16:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/10/18/spoj-dgame</id>
    <content type="html"><![CDATA[<p><strong>Prerequisites</strong> :  Game of Nim</p>

<p><strong><a href="http://www.spoj.com/problems/DGAME/">Problem</a></strong> : Game of Nim with variations. (N piles with i<sup>th</sup> pile containing either 2<em>i or 2</em>i+1 stones where even number of stones may be removed from selected pile.)</p>

<p><strong>Explanation</strong> :</p>

<p>At every index i, can have stones in two ways, so total no. of ways comes out to be 2 * 2 * . . . . * 2 (n times).</p>

<p>Now whether an index have 2<em>i or 2</em>i+1 stones the game remains unaffected because if there are 2<em>i+1 stones in any pile there will be one stone left out anyways, and the game will be same as the one played with 2</em>i stones. We shall be considering only this case.</p>

<p>At any point of the game i<sup>th</sup> pile contains 2*(i - k) stones (where k is any arbitrary constant). Now you can interpret the question as the ith pile had i stones in the beginning and you can take out any positive number of stones from it. This is the standard nim game containing N piles, where the ith pile contains i stones.</p>

<p>Now our task is to find XOR of N numbers(1 to N). Every number can be represented 4*p+q where 0 &lt;= q &lt;= 3 and p is any arbitrary.</p>

<p>For every N of type 4*p+3, it can be easily proved that XOR of 1 to N is 0. So the first person will always lose the game. The answer for such numbers is zero.</p>

<p>For N of type 4*p+1 XOR of numbers from 1 to N is 1, so the first player can remove 1 stone from any pile containing odd number of stones so that the XOR becomes zero. There are (N+1)/2 piles containing odd number of stones, so the answer for this case is (N+1)/2.</p>

<p>For numbers of type 4<em>p or 4</em>p+2 XOR is N and N+1 respectively So first player can make XOR zero by removing stones from any pile whose most significant bit is same as the most significant bit of N. Thus the answer for this case is the number of piles which has x stones, such that when x is represented in binary, it has the same number of bits as the binary representation of N. This can be obtained by subtracting from N the maximum power of 2 which is less than or equal to N.</p>

<p><strong>Links</strong> : <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=algorithmGames">Game of Nim</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ-RRSCHED]]></title>
    <link href="http://pag.sdslabs.co/blog//2013/10/03/spoj-rrsched/"/>
    <updated>2013-10-03T18:38:00+05:30</updated>
    <id>http://pag.sdslabs.co/blog//2013/10/03/spoj-rrsched</id>
    <content type="html"><![CDATA[<p><strong>Problem</strong> : <a href="http://www.spoj.com/problems/RRSCHED/">RRSCHED</a></p>

<p><strong>Difficulty</strong> : Medium</p>

<p><strong>Prerequisites</strong> : BIT</p>

<p><strong>Explanation</strong> : </p>

<p>A very naive approach would be to iterate over time and keep on decreasing the no of tasks to be performed and storing the task completion time in a separate array.This implementation would definitely give TLE  O(N*T) with the given constraints.</p>

<p>In the above approach we can observe that we can do better by jumping times from t = completion of easiest task (w.r.t time) to t = completion of next easiest task . </p>

<p>For this we need to sort the input array w.r.t time .But we would also want their original indices(because order matters).So you can use pair&lt;int,int&gt;  to store both the index and time  of a task.That way you would not lose your index’s by sorting the array.</p>

<p>In the following discussion:</p>

<p>Pair [i] denotes i th pair in sorted array
Pair[i].Time denotes time needed for ‘Pir[i].Index’ th task to complete.</p>

<p>Now for every iteration all we need to do is to keep track of  Current time and do as follows.</p>

<ol>
  <li>
    <p>Time Taken for present task to be completed
 = 	(no of remaining elements)*(Pair[i].Time-Pair[i-1].Time) +
 		1*no of Tasks before Pair[i].Index which are not completed</p>
  </li>
  <li>
    <p>Extra Time to complete the  round
 = 1*no of Tasks after Pair[i].Index which are not completed.</p>
  </li>
  <li>
    <p>Update Pair[i].Index as completed</p>
  </li>
</ol>

<p>Thus BIT comes in handy here where we have to query the no of tasks not completed and update a task as completed in O(logN). For this purpose initially keep a BIT array and update every element by ‘+1’ which means that the task is not completed yet.You can use Update(i,-1) to update the task as completed. You can find the no of tasks which are not completed  before an index i by Query(i).</p>

<p>The <a href="http://code.hackerearth.com/d8db76J">pesudo code</a> is as follows:</p>

<pre><code>//Initialize bit array to zero 

BIT[MaxN] = 0

// Update bit array 

Upadte(i , x)
	for(; i &lt;= n; i += i&amp;-i)
    	BIT[i] += x

//Query Cummulative Frequency in a bit array 

Query(i)
	s=0
	for(; i&gt;0 ; i-=i&amp;-i)
    	s += BIT[i]
	return s

//Take Input and Do the necessary initializations for BIT array

TakeInput()
for(i = 1; i &lt;= N; i++)
	Update(i, 1)

//Main Part

CurrentTime = 0
for(i = 1; i &lt;= N; i++)

	//N-i+1 total uncompleted tasks
	
	CurrentTime += (Pair[i].Time - Pair[i-1].Time - 1)*(N-i+1)
	
	//query for uncompleted tasks before the present task
	
	CurrentTime +=  Query(Pair[i].Index)
	
	//Store the final anwer for the present task
	
	Answer[Pair[i].Index] = CurrentTime
	
	//Update current task as completed
	
	Update(Pair[i].Index, -1)
	
	//Increase by no of uncompleted tasks after the present task
	
	CurrentTime += (N-i) - Query(Pair[i].Index)

//Note that the above psudo code also handles the case where two tasks have equal completion Time.
</code></pre>

]]></content>
  </entry>
  
</feed>
